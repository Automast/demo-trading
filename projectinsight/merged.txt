dashboard/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dashboard - YourApp</title>
  <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="../styles/main.css" />
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
    <div>Loading...</div>
  </div>

  <!-- Header -->
  <header class="header">
    <a href="/" class="logo">
      <img src="https://via.placeholder.com/32x32/00bcd4/ffffff?text=L" alt="Logo">
      <span>YourApp</span>
    </a>
    <button class="menu-toggle" id="mobileMenuToggle">
      <i class="material-icons">menu</i>
    </button>
    <div class="header-actions">
      <button class="notification-icon" id="notificationBtn">
        <i class="material-icons">notifications</i>
      </button>
      <button class="profile-button" id="profileBtn">
        <i class="material-icons">person</i>
        <span>Profile</span>
        <i class="material-icons">keyboard_arrow_down</i>
      </button>
    </div>
  </header>

  <!-- Sidebar -->
  <nav class="sidebar" id="sidebar">
    <div class="mobile-header">
      <h2>Menu</h2>
      <button class="mobile-close" id="mobileClose">
        <i class="material-icons">close</i>
      </button>
    </div>
    <div class="nav-container">
      <a href="#dashboard" class="nav-item active" data-page="dashboard">
        <i class="material-icons">dashboard</i>
        <span>Dashboard</span>
      </a>
      <a href="#deposit" class="nav-item" data-page="deposit">
        <i class="material-icons">add_circle_outline</i>
        <span>Deposit</span>
      </a>
      <a href="#withdraw" class="nav-item" data-page="withdraw">
        <i class="material-icons">remove_circle_outline</i>
        <span>Withdraw</span>
      </a>
      <a href="#assets" class="nav-item" data-page="assets">
        <i class="material-icons">account_balance_wallet</i>
        <span>Assets</span>
      </a>
      <a href="#markets" class="nav-item" data-page="markets">
        <i class="material-icons">pie_chart</i>
        <span>Markets</span>
      </a>
      <a href="#trade" class="nav-item" data-page="trade">
        <i class="material-icons">trending_up</i>
        <span>Trade</span>
      </a>
      <a href="#convert" class="nav-item" data-page="convert">
        <i class="material-icons">swap_horiz</i>
        <span>Convert</span>
      </a>
      <a href="#subscribe" class="nav-item" data-page="subscribe">
        <i class="material-icons">card_membership</i>
        <span>Subscribe</span>
      </a>
      <a href="#signals" class="nav-item" data-page="signals">
        <i class="material-icons">wifi</i>
        <span>Signals</span>
      </a>
      <a href="#stake" class="nav-item" data-page="stake">
        <i class="material-icons">local_offer</i>
        <span>Stake</span>
      </a>
      <a href="#referrals" class="nav-item" data-page="referrals">
        <i class="material-icons">group</i>
        <span>Referrals</span>
      </a>
      <a href="#connect" class="nav-item" data-page="connect">
        <i class="material-icons">link</i>
        <span>Connect Wallet</span>
      </a>
      <a href="#experts" class="nav-item" data-page="experts">
        <i class="material-icons">content_copy</i>
        <span>Copy Experts</span>
      </a>
    </div>
  </nav>

  <!-- Main Content Area -->
  <main class="content">
    <div id="page-content">
      <!-- Dynamic content loads here -->
    </div>
  </main>

  <!-- Notification Popup -->
  <div class="notification-popup" id="notificationPopup">
    <div class="popup-header">
      <h3>Notifications</h3>
      <button class="close-popup" id="closeNotifications">
        <i class="material-icons">close</i>
      </button>
    </div>
    <div class="popup-content">
      <div class="notification-empty">
        <i class="material-icons">notifications_none</i>
        <p>No new notifications</p>
        <p>You'll see your notifications here</p>
      </div>
    </div>
  </div>

  <!-- Profile Dropdown -->
  <div class="profile-dropdown" id="profileDropdown">
    <a href="#" class="dropdown-item" id="profileSettingsBtn">
      <i class="material-icons">settings</i>
      <span>Settings</span>
    </a>
    <a href="#" class="dropdown-item" id="profileDetailsBtn">
      <i class="material-icons">person</i>
      <span>Profile</span>
    </a>
    <div class="dropdown-divider"></div>
    <a href="#" class="dropdown-item" id="logoutBtn">
      <i class="material-icons">logout</i>
      <span>Logout</span>
    </a>
  </div>

  <!-- Side Modals -->
  <div class="modal-overlay" id="modalOverlay"></div>
  
  <!-- Profile Modal -->
  <div class="side-modal" id="profileModal">
    <div class="modal-header">
      <h2>Profile</h2>
      <button class="close-modal" id="closeProfileModal">
        <i class="material-icons">close</i>
      </button>
    </div>
    <div class="modal-content">
      <div class="profile-section">
        <div class="profile-avatar">
          <i class="material-icons">person</i>
        </div>
        <div class="profile-info">
          <h3 id="profileName">User Name</h3>
          <p id="profileEmail">user@email.com</p>
        </div>
      </div>
      <div class="profile-details">
        <div class="detail-item">
          <label>First Name</label>
          <input type="text" id="firstName" readonly />
        </div>
        <div class="detail-item">
          <label>Last Name</label>
          <input type="text" id="lastName" readonly />
        </div>
        <div class="detail-item">
          <label>Email</label>
          <input type="email" id="email" readonly />
        </div>
        <div class="detail-item">
          <label>Phone</label>
          <input type="text" id="phone" readonly />
        </div>
        <div class="detail-item">
          <label>Country</label>
          <input type="text" id="country" readonly />
        </div>
        <div class="detail-item">
          <label>Account Currency</label>
          <input type="text" id="accountCurrency" readonly />
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="side-modal" id="settingsModal">
    <div class="modal-header">
      <h2>Settings</h2>
      <button class="close-modal" id="closeSettingsModal">
        <i class="material-icons">close</i>
      </button>
    </div>
    <div class="modal-content">
      <div class="settings-section">
        <h3>Account Settings</h3>
        <div class="setting-item">
          <label>Two-Factor Authentication</label>
          <div class="toggle-switch">
            <input type="checkbox" id="twoFactorToggle" />
            <span class="slider"></span>
          </div>
        </div>
        <div class="setting-item">
          <label>Email Notifications</label>
          <div class="toggle-switch">
            <input type="checkbox" id="emailNotifications" checked />
            <span class="slider"></span>
          </div>
        </div>
        <div class="setting-item">
          <label>SMS Notifications</label>
          <div class="toggle-switch">
            <input type="checkbox" id="smsNotifications" />
            <span class="slider"></span>
          </div>
        </div>
      </div>
      <div class="settings-section">
        <h3>Display Settings</h3>
        <div class="setting-item">
          <label>Theme</label>
          <select id="themeSelect">
            <option value="dark">Dark</option>
            <option value="light">Light</option>
            <option value="auto">Auto</option>
          </select>
        </div>
        <div class="setting-item">
          <label>Language</label>
          <select id="languageSelect">
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <!-- Connect Wallet Modal -->
  <div class="side-modal right-modal" id="connectWalletModal">
    <div class="modal-header">
      <h2>Connect Wallet</h2>
      <button class="close-modal" id="closeConnectModal">
        <i class="material-icons">close</i>
      </button>
    </div>
    <div class="modal-content">
      <div class="wallet-options">
        <div class="wallet-option">
          <div class="wallet-icon">
            <img src="https://via.placeholder.com/40x40/ff6b35/ffffff?text=M" alt="MetaMask" />
          </div>
          <div class="wallet-info">
            <h4>MetaMask</h4>
            <p>Connect using browser wallet</p>
          </div>
          <button class="connect-btn">Connect</button>
        </div>
        <div class="wallet-option">
          <div class="wallet-icon">
            <img src="https://via.placeholder.com/40x40/3375bb/ffffff?text=W" alt="WalletConnect" />
          </div>
          <div class="wallet-info">
            <h4>WalletConnect</h4>
            <p>Scan QR code with mobile wallet</p>
          </div>
          <button class="connect-btn">Connect</button>
        </div>
        <div class="wallet-option">
          <div class="wallet-icon">
            <img src="https://via.placeholder.com/40x40/f0b90b/ffffff?text=B" alt="Binance" />
          </div>
          <div class="wallet-info">
            <h4>Binance Wallet</h4>
            <p>Connect to Binance Chain Wallet</p>
          </div>
          <button class="connect-btn">Connect</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Referrals Modal -->
  <div class="side-modal wide-modal" id="referralsModal">
    <div class="modal-header">
      <h2>Referral Program</h2>
      <button class="close-modal" id="closeReferralsModal">
        <i class="material-icons">close</i>
      </button>
    </div>
    <div class="modal-content">
      <div class="referral-stats">
        <div class="stat-card">
          <div class="stat-value">0</div>
          <div class="stat-label">Total Referrals</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">$0.00</div>
          <div class="stat-label">Total Earned</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">15%</div>
          <div class="stat-label">Commission Rate</div>
        </div>
      </div>
      <div class="referral-link">
        <label>Your Referral Link</label>
        <div class="link-input">
          <input type="text" id="referralLinkInput" value="https://yourapp.com/signup?ref=USER123" readonly />
          <button class="copy-btn" id="copyReferralLink">
            <i class="material-icons">content_copy</i>
          </button>
        </div>
      </div>
      <div class="referral-history">
        <h3>Referral History</h3>
        <div class="empty-state">
          <i class="material-icons">people</i>
          <p>No referrals yet</p>
          <p>Share your link to start earning!</p>
        </div>
      </div>
    </div>
  </div>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="../scripts/dashboard.js"></script>
<script src="../scripts/deposit.js"></script>
<script src="../scripts/withdraw.js"></script>
<script src="../scripts/assets.js"></script>
<script src="../scripts/markets.js"></script>
<script src="../scripts/trade.js"></script>


</body>
</html>

error/404.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Page Not Found - YourApp</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="../styles/main.css" />
</head>
<body>
  <header class="header">
    <a href="/" class="logo">
      <img src="https://via.placeholder.com/32x32/00bcd4/ffffff?text=L" alt="Logo">
      <span>YourApp</span>
    </a>
    <div class="header-actions">
      <a href="/login/" class="btn btn-secondary">Login</a>
      <a href="/dashboard/" class="btn btn-primary">Dashboard</a>
    </div>
  </header>

  <main style="margin-top: 70px; min-height: calc(100vh - 70px); display: flex; align-items: center; justify-content: center; padding: 2rem;">
    <div class="text-center" style="max-width: 500px;">
      <div style="font-size: 8rem; color: var(--accent-color); margin-bottom: 1rem; font-weight: 700;">
        404
      </div>
      
      <h1 style="font-size: 2rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-color);">
        Page Not Found
      </h1>
      
      <p style="color: var(--text-secondary); margin-bottom: 2rem; font-size: 1.1rem; line-height: 1.6;">
        The page you're looking for doesn't exist. It might have been moved, deleted, or you entered the wrong URL.
      </p>
      
      <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
        <a href="/" class="btn btn-primary">
          <i class="material-icons">home</i>
          Go Home
        </a>
        <a href="/dashboard/" class="btn btn-secondary">
          <i class="material-icons">dashboard</i>
          Dashboard
        </a>
      </div>
      
      <div style="margin-top: 3rem; padding: 1.5rem; background: var(--secondary-bg); border-radius: 12px; border: 1px solid var(--border-color);">
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-color);">
          Quick Links
        </h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem;">
          <a href="/login/" class="text-accent" style="text-decoration: none; padding: 0.5rem; border-radius: 8px; transition: background 0.3s;">
            <i class="material-icons" style="display: block; margin-bottom: 0.5rem;">login</i>
            Login
          </a>
          <a href="/signup/" class="text-accent" style="text-decoration: none; padding: 0.5rem; border-radius: 8px; transition: background 0.3s;">
            <i class="material-icons" style="display: block; margin-bottom: 0.5rem;">person_add</i>
            Sign Up
          </a>
          <a href="/dashboard/" class="text-accent" style="text-decoration: none; padding: 0.5rem; border-radius: 8px; transition: background 0.3s;">
            <i class="material-icons" style="display: block; margin-bottom: 0.5rem;">dashboard</i>
            Dashboard
          </a>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Check if user is logged in and update header
    (async function checkAuth() {
      try {
        const response = await fetch('/api/auth/me', { 
          credentials: 'include' 
        });
        
        if (response.ok) {
          // User is logged in, show dashboard link
          const headerActions = document.querySelector('.header-actions');
          headerActions.innerHTML = '<a href="/dashboard/" class="btn btn-primary">Go to Dashboard</a>';
        }
      } catch (error) {
        // User not logged in, keep current header
      }
    })();
  </script>

  <style>
    .text-accent {
      color: var(--accent-color);
      font-size: 0.9rem;
      font-weight: 500;
    }
    
    .text-accent:hover {
      background: var(--hover-bg);
    }
    
    @media (max-width: 768px) {
      main {
        padding: 1rem !important;
      }
      
      div[style*="font-size: 8rem"] {
        font-size: 5rem !important;
      }
      
      h1 {
        font-size: 1.5rem !important;
      }
      
      .btn {
        width: 100%;
        margin-bottom: 0.5rem;
      }
    }
  </style>
</body>
</html>

error/500.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Server Error - YourApp</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="../styles/main.css" />
</head>
<body>
  <header class="header">
    <a href="/" class="logo">
      <img src="https://via.placeholder.com/32x32/00bcd4/ffffff?text=L" alt="Logo">
      <span>YourApp</span>
    </a>
    <div class="header-actions">
      <a href="/login/" class="btn btn-secondary">Login</a>
      <a href="/dashboard/" class="btn btn-primary">Dashboard</a>
    </div>
  </header>

  <main style="margin-top: 70px; min-height: calc(100vh - 70px); display: flex; align-items: center; justify-content: center; padding: 2rem;">
    <div class="text-center" style="max-width: 500px;">
      <div style="font-size: 6rem; color: var(--error-color); margin-bottom: 1rem; font-weight: 700;">
        <i class="material-icons" style="font-size: inherit;">error</i>
      </div>
      
      <h1 style="font-size: 2rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-color);">
        Server Error
      </h1>
      
      <p style="color: var(--text-secondary); margin-bottom: 2rem; font-size: 1.1rem; line-height: 1.6;">
        We're experiencing some technical difficulties. Our team has been notified and is working to fix the issue.
      </p>
      
      <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-bottom: 2rem;">
        <button onclick="location.reload()" class="btn btn-primary">
          <i class="material-icons">refresh</i>
          Try Again
        </button>
        <a href="/" class="btn btn-secondary">
          <i class="material-icons">home</i>
          Go Home
        </a>
      </div>
      
      <div style="padding: 1.5rem; background: var(--secondary-bg); border-radius: 12px; border: 1px solid var(--border-color); text-align: left;">
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-color);">
          What you can do:
        </h3>
        <ul style="color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
          <li>Wait a few minutes and try again</li>
          <li>Check your internet connection</li>
          <li>Clear your browser cache and cookies</li>
          <li>Contact support if the problem persists</li>
        </ul>
      </div>
      
      <div style="margin-top: 2rem;">
        <p style="color: var(--text-secondary); font-size: 0.9rem;">
          Error ID: <code style="background: var(--primary-bg); padding: 0.25rem 0.5rem; border-radius: 4px; font-family: monospace;" id="errorId"></code>
        </p>
      </div>
    </div>
  </main>

  <script>
    // Generate a random error ID for tracking
    document.getElementById('errorId').textContent = 'ERR-' + Math.random().toString(36).substr(2, 9).toUpperCase();

    // Check if user is logged in and update header
    (async function checkAuth() {
      try {
        const response = await fetch('/api/auth/me', { 
          credentials: 'include' 
        });
        
        if (response.ok) {
          const headerActions = document.querySelector('.header-actions');
          headerActions.innerHTML = '<a href="/dashboard/" class="btn btn-primary">Go to Dashboard</a>';
        }
      } catch (error) {
        // User not logged in or API is down, keep current header
      }
    })();

    // Auto-retry after 30 seconds
    let retryCountdown = 30;
    const retryBtn = document.querySelector('button[onclick="location.reload()"]');
    const originalText = retryBtn.innerHTML;

    function updateRetryButton() {
      if (retryCountdown > 0) {
        retryBtn.innerHTML = `<i class="material-icons">refresh</i>Auto-retry in ${retryCountdown}s`;
        retryCountdown--;
        setTimeout(updateRetryButton, 1000);
      } else {
        location.reload();
      }
    }

    // Start countdown after 5 seconds
    setTimeout(() => {
      updateRetryButton();
    }, 5000);
  </script>

  <style>
    code {
      background: var(--primary-bg);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
    }
    
    @media (max-width: 768px) {
      main {
        padding: 1rem !important;
      }
      
      h1 {
        font-size: 1.5rem !important;
      }
      
      .btn {
        width: 100%;
        margin-bottom: 0.5rem;
      }
    }
  </style>
</body>
</html>

index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>YourApp - Trading Platform</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="styles/main.css" />
</head>
<body>
  <header class="header" style="position: relative; z-index: 100;">
    <div class="logo">
      <img src="https://via.placeholder.com/32x32/00bcd4/ffffff?text=L" alt="Logo" />
      <span>YourApp</span>
    </div>
    <div class="header-actions">
      <a href="/login/" class="btn btn-secondary">Login</a>
      <a href="/signup/" class="btn btn-primary">Sign Up</a>
    </div>
  </header>

  <main style="margin-top: 70px;">
    <!-- Hero Section -->
    <section class="hero" style="padding: 4rem 2rem; text-align: center; background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);">
      <div style="max-width: 800px; margin: 0 auto;">
        <h1 style="font-size: 3rem; font-weight: 700; margin-bottom: 1rem; background: linear-gradient(135deg, var(--accent-color), #00acc1); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
          The Future of Trading
        </h1>
        <p style="font-size: 1.25rem; color: var(--text-secondary); margin-bottom: 2rem; line-height: 1.6;">
          Trade cryptocurrencies, stocks, and more with our advanced platform. 
          Start your journey with professional tools and real-time market data.
        </p>
        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
          <a href="/signup/" class="btn btn-primary" style="padding: 1rem 2rem; font-size: 1.1rem;">
            <i class="material-icons">trending_up</i>
            Start Trading
          </a>
          <a href="/login/" class="btn btn-secondary" style="padding: 1rem 2rem; font-size: 1.1rem;">
            <i class="material-icons">login</i>
            Login
          </a>
        </div>
      </div>
    </section>

    <!-- Features Section -->
    <section style="padding: 4rem 2rem; max-width: 1200px; margin: 0 auto;">
      <h2 style="text-align: center; font-size: 2.5rem; font-weight: 600; margin-bottom: 3rem; color: var(--text-color);">
        Why Choose YourApp?
      </h2>
      
      <div class="stats-grid" style="margin-bottom: 4rem;">
        <div class="stat-card">
          <div class="stat-icon">
            <i class="material-icons">security</i>
          </div>
          <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem;">Bank-Grade Security</h3>
          <p style="color: var(--text-secondary);">Your funds and data are protected with enterprise-level security measures.</p>
        </div>

        <div class="stat-card">
          <div class="stat-icon">
            <i class="material-icons">speed</i>
          </div>
          <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem;">Lightning Fast</h3>
          <p style="color: var(--text-secondary);">Execute trades instantly with our high-performance trading engine.</p>
        </div>

        <div class="stat-card">
          <div class="stat-icon">
            <i class="material-icons">analytics</i>
          </div>
          <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem;">Advanced Analytics</h3>
          <p style="color: var(--text-secondary);">Professional trading tools and real-time market analysis.</p>
        </div>

        <div class="stat-card">
          <div class="stat-icon">
            <i class="material-icons">support_agent</i>
          </div>
          <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem;">24/7 Support</h3>
          <p style="color: var(--text-secondary);">Get help whenever you need it with our dedicated support team.</p>
        </div>
      </div>

      <!-- Markets Preview -->
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">Live Market Data</h3>
          <p style="color: var(--text-secondary); font-size: 0.9rem;">Real-time prices updated every second</p>
        </div>
        <div class="card-body">
          <div class="table-container">
            <table class="table">
              <thead>
                <tr>
                  <th>Asset</th>
                  <th>Price</th>
                  <th>24h Change</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                      <div style="width: 24px; height: 24px; background: #f7931a; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.7rem;">₿</div>
                      Bitcoin (BTC)
                    </div>
                  </td>
                  <td>$45,234.56</td>
                  <td style="color: var(--success-color);">+2.34%</td>
                  <td>
                    <a href="/signup/" class="btn btn-primary btn-sm">Trade</a>
                  </td>
                </tr>
                <tr>
                  <td>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                      <div style="width: 24px; height: 24px; background: #627eea; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.7rem;">Ξ</div>
                      Ethereum (ETH)
                    </div>
                  </td>
                  <td>$2,856.78</td>
                  <td style="color: var(--success-color);">+1.89%</td>
                  <td>
                    <a href="/signup/" class="btn btn-primary btn-sm">Trade</a>
                  </td>
                </tr>
                <tr>
                  <td>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                      <div style="width: 24px; height: 24px; background: #00d4aa; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.7rem;">$</div>
                      Tether (USDT)
                    </div>
                  </td>
                  <td>$1.00</td>
                  <td style="color: var(--text-secondary);">0.00%</td>
                  <td>
                    <a href="/signup/" class="btn btn-primary btn-sm">Trade</a>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <!-- CTA Section -->
    <section style="padding: 4rem 2rem; text-align: center; background: var(--secondary-bg); margin: 2rem 0;">
      <div style="max-width: 600px; margin: 0 auto;">
        <h2 style="font-size: 2rem; font-weight: 600; margin-bottom: 1rem;">Ready to Get Started?</h2>
        <p style="color: var(--text-secondary); margin-bottom: 2rem;">
          Join thousands of traders who trust YourApp for their trading needs. 
          Sign up today and get access to premium features.
        </p>
        <a href="/signup/" class="btn btn-primary" style="padding: 1rem 2rem; font-size: 1.1rem;">
          <i class="material-icons">account_circle</i>
          Create Free Account
        </a>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer style="padding: 2rem; text-align: center; border-top: 1px solid var(--border-color);">
    <div style="max-width: 800px; margin: 0 auto;">
      <div class="logo" style="justify-content: center; margin-bottom: 1rem;">
        <img src="https://via.placeholder.com/32x32/00bcd4/ffffff?text=L" alt="Logo" />
        <span>YourApp</span>
      </div>
      <p style="color: var(--text-secondary); font-size: 0.9rem;">
        © 2025 YourApp. All rights reserved. Trading involves risk and may not be suitable for all investors.
      </p>
    </div>
  </footer>

  <script>
    // Check if user is already logged in and redirect to dashboard
    (async function checkAuth() {
      try {
        const response = await fetch('/api/auth/me', { 
          credentials: 'include' 
        });
        
        if (response.ok) {
          // User is logged in, redirect to dashboard
          window.location.href = '/dashboard/';
        }
      } catch (error) {
        // User not logged in, stay on homepage
        console.log('User not authenticated');
      }
    })();

    // Animate stats on scroll
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.style.animation = 'fadeIn 0.6s ease-out forwards';
        }
      });
    }, observerOptions);

    document.querySelectorAll('.stat-card').forEach(card => {
      observer.observe(card);
    });
  </script>

  <style>
    .hero {
      background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
      position: relative;
      overflow: hidden;
    }

    .hero::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="%2300bcd4" opacity="0.1"/><circle cx="80" cy="40" r="1" fill="%2300bcd4" opacity="0.2"/><circle cx="50" cy="70" r="1.5" fill="%2300bcd4" opacity="0.1"/></svg>');
      animation: float 20s infinite linear;
    }

    @keyframes float {
      0% { transform: translateY(0) rotate(0deg); }
      100% { transform: translateY(-100px) rotate(360deg); }
    }

    .btn-sm {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
    }

    @media (max-width: 768px) {
      .hero h1 {
        font-size: 2rem !important;
      }
      
      .hero p {
        font-size: 1rem !important;
      }

      .hero .btn {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .stats-grid {
        grid-template-columns: 1fr !important;
      }
    }
  </style>
</body>
</html>

pages/assets/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assets</title>
</head>
<body>
  <div class="card">
    <div class="card-header">
      <h2 class="card-title">Assets</h2>
      <div class="balance" id="totalBalanceDisplay">Total Balance: 0.00</div>
    </div>
    <div class="card-body">
      <div class="form-container" style="max-width: 100%; margin: 0;">
        <div class="form-group">
          <input type="text" id="searchBar" class="form-control" placeholder="Search assets..." />
        </div>
        <div class="form-group">
          <select id="filterSelect" class="form-control">
            <option value="All">All Types</option>
            <option value="Crypto">Crypto</option>
            <option value="Fiat">Fiat</option>
            <option value="Stocks">Stocks</option>
          </select>
        </div>
      </div>

      <div class="table-container">
        <table class="table">
          <thead>
            <tr>
              <th>★</th>
              <th>Asset</th>
              <th>Type</th>
              <th>Current Price (EUR)</th>
              <th>In Your Wallet</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="assetsTableBody">
            <!-- Populated by JS -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-header">
      <h2 class="card-title">Recent Activity</h2>
    </div>
    <div class="card-body">
      <div id="notificationList">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <script>
    let currentUser = null;
    let userWallets = [];
    let coinPricesUSD = {};
    let exchangeRates = {};
    let userCurrency = 'USD';
    let notifications = [];

    const assets = [
      { symbol: 'AAPL',  name: 'Apple',                    type: 'Stocks' },
      { symbol: 'AAVE',  name: 'AAVE',                     type: 'Crypto' },
      { symbol: 'ABT',   name: 'Abbot Labs',               type: 'Stocks' },
      { symbol: 'ADA',   name: 'Cardano',                  type: 'Crypto' },
      { symbol: 'ADBE',  name: 'Adobe',                    type: 'Stocks' },
      { symbol: 'ALGO',  name: 'Algorand',                 type: 'Crypto' },
      { symbol: 'AMZN',  name: 'Amazon',                   type: 'Stocks' },
      { symbol: 'AUD',   name: 'Australian Dollar',        type: 'Fiat'   },
      { symbol: 'AVAX',  name: 'Avalanche',                type: 'Crypto' },
      { symbol: 'AXS',   name: 'Axie Infinity',            type: 'Crypto' },
      { symbol: 'BABA',  name: 'Alibaba',                  type: 'Stocks' },
      { symbol: 'BAC',   name: 'Bank of America',          type: 'Stocks' },
      { symbol: 'BCH',   name: 'Bitcoin Cash',             type: 'Crypto' },
      { symbol: 'BTC',   name: 'Bitcoin',                  type: 'Crypto' },
      { symbol: 'CAD',   name: 'Canadian Dollar',          type: 'Fiat'   },
      { symbol: 'CHF',   name: 'Swiss Franc',              type: 'Fiat'   },
      { symbol: 'CRO',   name: 'Cronos',                   type: 'Crypto' },
      { symbol: 'DAI',   name: 'Dai',                      type: 'Crypto' },
      { symbol: 'DOGE',  name: 'Dogecoin',                 type: 'Crypto' },
      { symbol: 'DOT',   name: 'Polkadot',                 type: 'Crypto' },
      { symbol: 'ETH',   name: 'Ethereum',                 type: 'Crypto' },
      { symbol: 'EUR',   name: 'Euro',                     type: 'Fiat'   },
      { symbol: 'FB',    name: 'Meta Platforms Inc',       type: 'Stocks' },
      { symbol: 'GBP',   name: 'British Pound',            type: 'Fiat'   },
      { symbol: 'GOOGL', name: 'Google',                   type: 'Stocks' },
      { symbol: 'LTC',   name: 'Litecoin',                 type: 'Crypto' },
      { symbol: 'MATIC', name: 'Polygon',                  type: 'Crypto' },
      { symbol: 'MSFT',  name: 'Microsoft',                type: 'Stocks' },
      { symbol: 'PEPE',  name: 'Pepe',                     type: 'Crypto' },
      { symbol: 'SOL',   name: 'Solana',                   type: 'Crypto' },
      { symbol: 'TSLA',  name: 'Tesla',                    type: 'Stocks' },
      { symbol: 'UNI',   name: 'Uniswap',                  type: 'Crypto' },
      { symbol: 'USD',   name: 'United States Dollar',     type: 'Fiat'   },
      { symbol: 'USDC',  name: 'USD Coin',                 type: 'Crypto' },
      { symbol: 'USDT',  name: 'Tether',                   type: 'Crypto' },
      { symbol: 'XRP',   name: 'Ripple',                   type: 'Crypto' }
    ];

    const coinGeckoMap = {
      BTC: 'bitcoin',
      ETH: 'ethereum',
      USDC: 'usd-coin',
      USDT: 'tether',
      BNB: 'binancecoin',
      ADA: 'cardano',
      DOGE: 'dogecoin',
      SOL: 'solana',
      AVAX: 'avalanche-2',
      SHIB: 'shiba-inu',
      LTC: 'litecoin',
      TRX: 'tron',
      MATIC: 'matic-network',
      PEPE: 'pepe',
      XRP: 'ripple',
      CRO: 'crypto-com-chain',
      DAI: 'dai',
      UNI: 'uniswap',
      AAVE: 'aave',
      ALGO: 'algorand',
      BCH: 'bitcoin-cash',
      AXS: 'axie-infinity'
    };

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await checkAuth();
        await fetchCoinPrices();
        await fetchExchangeRates();
        await fetchUserWallets();
        updateTotalBalanceDisplay();
        await fetchNotifications();
        displayRecentNotifications();
        await markNotificationsRead();

        document.getElementById('searchBar').addEventListener('input', renderTable);
        document.getElementById('filterSelect').addEventListener('change', renderTable);

        renderTable();

      } catch (error) {
        console.error('Assets page initialization error:', error);
      }
    });

    async function checkAuth() {
      const meRes = await fetch('/api/auth/me', { credentials: 'include' });
      if (!meRes.ok) {
        throw new Error('Not logged in');
      }
      const meData = await meRes.json();
      currentUser = meData.user;
      userCurrency = currentUser.accountCurrency || 'USD';
    }

    async function fetchCoinPrices() {
      try {
        const res = await fetch('/api/coin-prices', { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch coin prices: ${res.status}`);
        }
        coinPricesUSD = await res.json();
      } catch (err) {
        console.error('Error fetching coin prices:', err);
        coinPricesUSD = {};
      }
    }

    async function fetchExchangeRates() {
      const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b'; 
      const url = `https://v6.exchangerate-api.com/v6/${EXCHANGE_RATE_API_KEY}/latest/USD`;
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Exchange rate fetch failed: ${res.status}`);
        }
        const data = await res.json();
        exchangeRates = data.conversion_rates || {};
      } catch (err) {
        console.error('Error fetching exchange rates:', err);
        exchangeRates = {};
      }
    }

    async function fetchUserWallets() {
      try {
        const res = await fetch(`/api/user/${currentUser.id}/wallets`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch user wallets: ${res.status}`);
        }
        userWallets = await res.json();
      } catch (err) {
        console.error('Error fetching wallets:', err);
        userWallets = [];
      }
    }

    function calculateTotalBalance() {
      let totalLocal = 0;

      for (let w of userWallets) {
        const balNum = parseFloat(w.balance || '0');
        if (isNaN(balNum) || balNum <= 0) continue;

        if (w.shortName.toUpperCase() === userCurrency.toUpperCase()) {
          totalLocal += balNum;
          continue;
        }

        const usdVal = balNum * getUsdPriceFromShortName(w.shortName);
        const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
        const localVal = usdVal * rate;
        totalLocal += localVal;
      }

      return totalLocal;
    }

    function updateTotalBalanceDisplay() {
      const total = calculateTotalBalance();
      document.getElementById('totalBalanceDisplay').textContent = 
        `Total Balance: ${formatNumber(total)} ${userCurrency}`;
    }

    async function fetchNotifications() {
      try {
        const res = await fetch(`/api/user/${currentUser.id}/notifications`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Could not fetch notifications: ${res.status}`);
        }
        const allNotes = await res.json();
        notifications = allNotes.slice(0, 5);
      } catch (err) {
        console.error('Error fetching notifications:', err);
        notifications = [];
      }
    }

    function displayRecentNotifications() {
      const list = document.getElementById('notificationList');
      list.innerHTML = '';

      if (notifications.length === 0) {
        list.innerHTML = '<div class="text-center text-muted">No recent notifications.</div>';
        return;
      }

      notifications.forEach(note => {
        const div = document.createElement('div');
        div.className = 'mb-2 p-3 bg-primary rounded';
        div.textContent = note.message;
        list.appendChild(div);
      });
    }

    async function markNotificationsRead() {
      if (!notifications.length) return;
      try {
        await fetch(`/api/user/${currentUser.id}/notifications-mark-all`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ isRead: 1 })
        });
      } catch (err) {
        console.error('Error marking notifications read:', err);
      }
    }

    function renderTable() {
      const searchQuery = document.getElementById('searchBar').value.toLowerCase();
      const filterType = document.getElementById('filterSelect').value;
      const starredSymbols = getStarredAssets();

      let filtered = assets.filter(a => {
        const matchesSearch = a.name.toLowerCase().includes(searchQuery) ||
                              a.symbol.toLowerCase().includes(searchQuery);
        const matchesFilter = (filterType === 'All') || (a.type === filterType);
        return matchesSearch && matchesFilter;
      });

      filtered.sort((a, b) => {
        const aStar = starredSymbols.includes(a.symbol);
        const bStar = starredSymbols.includes(b.symbol);
        if (aStar && !bStar) return -1;
        if (!aStar && bStar) return 1;
        return a.name.localeCompare(b.name);
      });

      const tbody = document.getElementById('assetsTableBody');
      tbody.innerHTML = '';

      for (let asset of filtered) {
        const tr = document.createElement('tr');

        const starTd = document.createElement('td');
        const starIcon = document.createElement('span');
        starIcon.textContent = '★';
        starIcon.classList.add('star');
        if (starredSymbols.includes(asset.symbol)) {
          starIcon.classList.add('filled');
        }
        starIcon.onclick = () => toggleStar(asset.symbol);
        starTd.appendChild(starIcon);
        tr.appendChild(starTd);

        const nameTd = document.createElement('td');
        nameTd.textContent = asset.name;
        tr.appendChild(nameTd);

        const typeTd = document.createElement('td');
        typeTd.textContent = asset.type;
        tr.appendChild(typeTd);

        let priceEur = 0;
        if (asset.type === 'Crypto') {
          const usdPrice = getUsdPriceFromShortName(asset.symbol);
          const eurRate = exchangeRates['EUR'] || 1;
          priceEur = usdPrice * eurRate;
        } else if (asset.type === 'Fiat') {
          priceEur = (asset.symbol === 'EUR') ? 1 : 0;
        } else {
          priceEur = 0;
        }
        const priceTd = document.createElement('td');
        priceTd.textContent = `€${formatNumber(priceEur)}/${asset.symbol}`;
        tr.appendChild(priceTd);

        let userBalance = '0.00';
        const foundWallet = userWallets.find(w => w.shortName.toUpperCase() === asset.symbol.toUpperCase());
        if (foundWallet && foundWallet.balance) {
          userBalance = foundWallet.balance;
        }
        const walletTd = document.createElement('td');
        walletTd.textContent = `${userBalance} ${asset.symbol}`;
        tr.appendChild(walletTd);

        const actionTd = document.createElement('td');
        const actionDiv = document.createElement('div');
        actionDiv.classList.add('d-flex');
        actionDiv.style.gap = '0.5rem';
        actionDiv.style.flexWrap = 'wrap';

        const depositBtn = document.createElement('button');
        depositBtn.textContent = 'Deposit';
        depositBtn.classList.add('btn', 'btn-primary', 'btn-sm');
        depositBtn.onclick = () => window.navigateToPage('deposit');
        actionDiv.appendChild(depositBtn);

        const withdrawBtn = document.createElement('button');
        withdrawBtn.textContent = 'Withdraw';
        withdrawBtn.classList.add('btn', 'btn-secondary', 'btn-sm');
        withdrawBtn.onclick = () => window.navigateToPage('withdraw');
        actionDiv.appendChild(withdrawBtn);

        actionTd.appendChild(actionDiv);
        tr.appendChild(actionTd);

        tbody.appendChild(tr);
      }
    }

    function getStarredAssets() {
      const name = 'starred=';
      const decoded = decodeURIComponent(document.cookie);
      const parts = decoded.split(';');
      for (let p of parts) {
        const c = p.trim();
        if (c.startsWith(name)) {
          return c.substring(name.length).split(',');
        }
      }
      return [];
    }

    function setStarredAssets(arr) {
      const expires = new Date();
      expires.setFullYear(expires.getFullYear() + 1);
      document.cookie = `starred=${arr.join(',')}; path=/; expires=${expires.toUTCString()}`;
    }

    function toggleStar(symbol) {
      let starred = getStarredAssets();
      if (starred.includes(symbol)) {
        starred = starred.filter(s => s !== symbol);
      } else {
        starred.push(symbol);
        alert('Added to watchlist');
      }
      setStarredAssets(starred);
      renderTable();
    }

    function getUsdPriceFromShortName(shortName) {
      const key = guessCoinGeckoKey(shortName);
      if (!coinPricesUSD[key] || !coinPricesUSD[key].usd) {
        return 1;
      }
      return coinPricesUSD[key].usd;
    }

    function guessCoinGeckoKey(shortName) {
      const upper = shortName.toUpperCase();
      if (coinGeckoMap[upper]) return coinGeckoMap[upper];
      return 'usd-coin';
    }

    function formatNumber(num) {
      if (!num || isNaN(num)) return '0.00';
      return parseFloat(num).toLocaleString('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6
      });
    }

    // Star styling
    const style = document.createElement('style');
    style.textContent = `
      .star {
        cursor: pointer;
        font-size: 18px;
        color: var(--text-secondary);
        transition: all 0.2s;
      }
      .star.filled {
        color: #ffd700;
      }
      .star:hover {
        transform: scale(1.2);
      }
      .btn-sm {
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>

pages/deposit/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Deposit</title>
</head>
<body>
  <div class="card">
    <div class="card-header">
      <h2 class="card-title">Deposit Funds</h2>
      <button class="btn btn-primary" id="openDepositBtn">
        <i class="material-icons">add</i>
        Make a Deposit
      </button>
    </div>
    <div class="card-body">
      <div class="form-container" style="max-width: 100%; margin: 0;">
        <div class="form-group">
          <input type="text" id="searchInput" class="form-control" placeholder="Search by reference/method/type..." />
        </div>
        <div class="form-group">
          <select id="statusFilter" class="form-control">
            <option value="">All Statuses</option>
            <option value="pending_user_confirmation">Pending User Confirmation</option>
            <option value="pending_approval">Pending Admin Approval</option>
            <option value="confirmed">Confirmed (Approved)</option>
            <option value="rejected_by_admin">Rejected by Admin</option>
            <option value="canceled">Canceled (System)</option>
          </select>
        </div>
      </div>

      <div class="table-container">
        <table class="table" id="depositTable">
          <thead>
            <tr>
              <th>ID</th>
              <th>Date</th>
              <th>Reference</th>
              <th>Method</th>
              <th>Type</th>
              <th>Amount</th>
              <th id="tableTotalHeader">Total (Local)</th>
              <th>User Status</th>
              <th>Admin Status</th>
              <th>Approved Amount</th>
              <th>Admin Remarks</th>
            </tr>
          </thead>
          <tbody>
            <!-- Populated via JS -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Modal Overlay -->
  <div class="modal-overlay" id="depositModalOverlay">
    <div class="side-modal right-modal" id="depositModal">
      <div class="modal-header">
        <h2>Create a Deposit</h2>
        <button class="close-modal" id="modalCloseBtn">
          <i class="material-icons">close</i>
        </button>
      </div>
      <div class="modal-content">
        <form id="depositForm">
          <div class="form-group">
            <label>Type</label>
            <select id="depositType" name="type" class="form-control">
              <option value="crypto" selected>Crypto</option>
            </select>
          </div>

          <div class="form-group">
            <label>Method (Select a Coin)</label>
            <select id="depositMethod" name="method" class="form-control">
              <!-- Populated by user wallets -->
            </select>
          </div>

          <div class="form-group">
            <label>Wallet Address</label>
            <div class="d-flex" style="gap: 0.5rem;">
              <input type="text" id="depositAddress" class="form-control" readonly />
              <button type="button" class="btn btn-secondary" id="copyAddressBtn">
                <i class="material-icons">content_copy</i>
              </button>
            </div>
          </div>

          <div class="form-group">
            <label>Amount (Crypto)</label>
            <input type="number" id="depositAmount" class="form-control" min="0" step="any" required />
          </div>

          <div class="form-group">
            <label>Equivalent in <span id="localCurrencyLabel">USD</span></label>
            <input type="text" id="localCurrencyEquivalent" class="form-control" readonly />
          </div>

          <button type="submit" class="btn btn-primary w-100" id="confirmDepositBtn">
            <i class="material-icons">add</i>
            Deposit
          </button>
        </form>

        <!-- Confirmation section after form is submitted -->
        <div class="confirmation-section" id="confirmationSection" style="display: none;">
          <div class="text-center">
            <i class="material-icons" style="font-size: 3rem; color: var(--success-color); margin-bottom: 1rem;">check_circle</i>
            <h3>Deposit Created Successfully!</h3>
          </div>
          <div class="mt-3">
            <p><strong>Reference:</strong> <span id="confirmRef"></span></p>
            <p><strong>Amount (Crypto):</strong> <span id="confirmAmountCrypto"></span></p>
            <p><strong>Local Currency:</strong> <span id="confirmAmountLocal"></span></p>
            <p><strong>Address:</strong> <span id="confirmAddress"></span> 
              <button class="btn btn-secondary btn-sm" id="copyConfirmAddressBtn">
                <i class="material-icons">content_copy</i>
              </button>
            </p>
            <p>User Status: <strong>Pending User Confirmation</strong></p>
            <p>Admin Status: <strong>Pending Approval</strong></p>
            <div class="mt-3 p-3 bg-primary rounded">
              <p class="mb-0"><strong>Next Steps:</strong></p>
              <p class="mb-0">Send your crypto to the wallet address above and wait for confirmation.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Include the deposit functionality
    let currentUser = null;
    let userWallets = [];
    let deposits = [];
    let coinPrices = {};
    let exchangeRates = {};
    let userCurrency = 'USD';

    // Telegram info
    const TELEGRAM_BOT_TOKEN = '7504988589:AAGRqHBTqeC7UH6AlX6TqAYn6u2wtTXkCcA'; 
    const TELEGRAM_CHAT_IDS = ['1277452628'];
    const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b';

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await fetchCurrentUser();
        await fetchCoinPrices();
        await fetchExchangeRates();
        await fetchUserWallets();
        await fetchUserDeposits();
        renderDepositTable();
        setupEventListeners();

        const tableTotalHeader = document.getElementById('tableTotalHeader');
        if (userCurrency) {
          tableTotalHeader.textContent = `Total (${userCurrency})`;
        }

      } catch (error) {
        console.error('Deposit page initialization error:', error);
      }
    });

    async function fetchCurrentUser() {
      const meRes = await fetch('/api/auth/me', { credentials: 'include' });
      if (!meRes.ok) {
        throw new Error('Not logged in');
      }
      const meData = await meRes.json();
      currentUser = meData.user;
      userCurrency = currentUser.accountCurrency || 'USD';
    }

    async function fetchCoinPrices() {
      try {
        const res = await fetch('/api/coin-prices', { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Coin prices fetch failed with status: ${res.status}`);
        }
        coinPrices = await res.json();
      } catch (err) {
        console.error('Error fetching coin prices:', err);
        coinPrices = {};
      }
    }

    async function fetchExchangeRates() {
      try {
        const url = `https://v6.exchangerate-api.com/v6/${EXCHANGE_RATE_API_KEY}/latest/USD`;
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Exchange rate fetch failed: ${res.status}`);
        }
        const data = await res.json();
        if (data.result === 'success') {
            exchangeRates = data.conversion_rates || {};
        } else {
            console.error("ExchangeRate-API success false:", data['error-type']);
            exchangeRates = {};
        }
      } catch (error) {
        console.error('Error fetching exchange rates:', error);
        exchangeRates = {};
      }
    }

    async function fetchUserWallets() {
      if (!currentUser || !currentUser.id) {
        console.error("Cannot fetch user wallets, user not authenticated.");
        userWallets = [];
        return;
      }
      try {
        const res = await fetch(`/api/user/${currentUser.id}/wallets`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch user wallets: ${res.status}`);
        }
        userWallets = await res.json();
      } catch (error) {
        console.error('Error fetching wallets:', error);
        userWallets = [];
      }
    }

    async function fetchUserDeposits() {
      if (!currentUser || !currentUser.id) {
        console.error("Cannot fetch user deposits, user not authenticated.");
        deposits = [];
        return;
      }
      try {
        const res = await fetch(`/api/user/${currentUser.id}/deposits`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch deposits: ${res.status}`);
        }
        deposits = await res.json();
      } catch (error) {
        console.error('Error fetching deposits:', error);
        deposits = [];
      }
    }

    function renderDepositTable() {
      const tbody = document.querySelector('#depositTable tbody');
      tbody.innerHTML = '';

      const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
      const filterStatus = document.getElementById('statusFilter').value;

      const sortedDeposits = [...deposits].sort((a, b) => new Date(b.createdAt || b.date) - new Date(a.createdAt || a.date));

      const filtered = sortedDeposits.filter(dep => {
        let matchesStatus = true;
        if (filterStatus) {
            if (filterStatus === 'pending_user_confirmation' && dep.status !== 'pending_user_confirmation') matchesStatus = false;
            else if (filterStatus === 'pending_approval' && dep.admin_status !== 'pending_approval' && dep.status === 'pending_user_confirmation') matchesStatus = false;
            else if (filterStatus === 'confirmed' && dep.status !== 'confirmed') matchesStatus = false;
            else if (filterStatus === 'rejected_by_admin' && dep.status !== 'rejected_by_admin') matchesStatus = false;
            else if (filterStatus === 'canceled' && dep.status !== 'canceled') matchesStatus = false;
            else if (filterStatus === 'pending_approval' && !(dep.status === 'pending_user_confirmation' && dep.admin_status === 'pending_approval')) matchesStatus = false;
        }

        const combinedSearchable = `${dep.reference} ${dep.method} ${dep.type} ${dep.admin_status} ${dep.admin_remarks || ''}`.toLowerCase();
        const matchesSearch = !searchTerm || combinedSearchable.includes(searchTerm);

        return matchesStatus && matchesSearch;
      });

      filtered.forEach(dep => {
        const tr = document.createElement('tr');

        ['id', 'date', 'reference', 'method', 'type', 'amount'].forEach(key => {
            const td = document.createElement('td');
            td.textContent = key === 'date' ? formatDate(dep[key]) : dep[key] || 'N/A';
            tr.appendChild(td);
        });
        
        // Total (local currency)
        const tdTotal = document.createElement('td');
        const shortName = dep.method;
        const coinKey = guessCoinGeckoKey(shortName);
        const coinUSDPrice = coinPrices[coinKey]?.usd ?? ( (shortName ==='USDT' || shortName === 'USDC') ? 1 : 0);
        const amountCrypto = parseFloat(dep.amount);
        const totalUSD = amountCrypto * coinUSDPrice;
        const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
        const totalLocal = totalUSD * rate;
        tdTotal.textContent = `${totalLocal.toFixed(2)} ${userCurrency}`;
        tr.appendChild(tdTotal);

        // User Status
        const tdUserStatus = document.createElement('td');
        tdUserStatus.textContent = dep.status;
        tdUserStatus.className = `status-${dep.status.toLowerCase().replace(/\s+/g, '_')}`;
        tr.appendChild(tdUserStatus);

        // Admin Status
        const tdAdminStatus = document.createElement('td');
        tdAdminStatus.textContent = dep.admin_status || 'N/A';
        tdAdminStatus.className = `status-${(dep.admin_status || '').toLowerCase().replace(/\s+/g, '_')}`;
        tr.appendChild(tdAdminStatus);

        // Approved Amount
        const tdApprovedAmount = document.createElement('td');
        if (dep.admin_status === 'approved' || dep.admin_status === 'rejected') {
            tdApprovedAmount.textContent = dep.admin_approved_amount !== null ? dep.admin_approved_amount : 'N/A';
        } else {
            tdApprovedAmount.textContent = 'N/A';
        }
        tr.appendChild(tdApprovedAmount);
        
        // Admin Remarks
        const tdAdminRemarks = document.createElement('td');
        tdAdminRemarks.textContent = dep.admin_remarks || 'N/A';
        if (dep.admin_remarks && dep.admin_remarks.length > 30) {
            tdAdminRemarks.title = dep.admin_remarks;
            tdAdminRemarks.textContent = dep.admin_remarks.substring(0, 27) + '...';
        }
        tr.appendChild(tdAdminRemarks);

        tbody.appendChild(tr);
      });
    }

    function setupEventListeners() {
      document.getElementById('searchInput').addEventListener('input', renderDepositTable);
      document.getElementById('statusFilter').addEventListener('change', renderDepositTable);
      document.getElementById('openDepositBtn').addEventListener('click', openDepositModal);
      document.getElementById('modalCloseBtn').addEventListener('click', closeDepositModal);
      document.getElementById('copyAddressBtn').addEventListener('click', copyWalletAddress);
      document.getElementById('copyConfirmAddressBtn').addEventListener('click', copyConfirmWalletAddress);
      document.getElementById('depositMethod').addEventListener('change', onChangeCoinMethod);
      document.getElementById('depositAmount').addEventListener('input', updateLocalCurrencyEquivalent);
      document.getElementById('depositForm').addEventListener('submit', onDepositFormSubmit);
    }

    function openDepositModal() {
      const form = document.getElementById('depositForm');
      form.style.display = 'flex';
      form.reset();
      document.getElementById('confirmationSection').style.display = 'none';
      populateMethodDropdown();
      document.getElementById('localCurrencyLabel').textContent = userCurrency;
      onChangeCoinMethod();
      document.getElementById('depositModalOverlay').style.display = 'flex';
    }

    function closeDepositModal() {
      document.getElementById('depositModalOverlay').style.display = 'none';
    }

    function populateMethodDropdown() {
      const methodSelect = document.getElementById('depositMethod');
      methodSelect.innerHTML = ''; 

      const depositableWallets = userWallets.filter(wallet => {
        const coinKey = guessCoinGeckoKey(wallet.shortName);
        return coinPrices.hasOwnProperty(coinKey) || wallet.shortName === 'USDT' || wallet.shortName === 'USDC';
      });

      if (depositableWallets.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No depositable wallets';
        option.disabled = true;
        methodSelect.appendChild(option);
        document.getElementById('depositAddress').value = '';
        return;
      }

      depositableWallets.forEach(wallet => {
        const option = document.createElement('option');
        option.value = wallet.shortName; 
        option.textContent = `${wallet.coinName} (${wallet.shortName})`;
        option.setAttribute('data-address', wallet.walletAddress);
        methodSelect.appendChild(option);
      });
      onChangeCoinMethod(); 
    }

    function onChangeCoinMethod() {
      const methodSelect = document.getElementById('depositMethod');
      if (methodSelect.options.length > 0 && methodSelect.selectedIndex !== -1) {
        const selectedOption = methodSelect.options[methodSelect.selectedIndex];
        const address = selectedOption.getAttribute('data-address') || '';
        document.getElementById('depositAddress').value = address;
      } else {
         document.getElementById('depositAddress').value = 'No wallet selected or available';
      }
      updateLocalCurrencyEquivalent();
    }

    function copyWalletAddress() {
      const addressField = document.getElementById('depositAddress');
      navigator.clipboard.writeText(addressField.value)
        .then(() => alert('Address copied!'))
        .catch(err => {
          console.error('Failed to copy address:', err);
          alert('Failed to copy.');
        });
    }

    function copyConfirmWalletAddress() {
      const addressText = document.getElementById('confirmAddress').textContent;
      navigator.clipboard.writeText(addressText)
        .then(() => alert('Address copied!'))
        .catch(err => {
          console.error('Failed to copy address:', err);
          alert('Failed to copy.');
        });
    }

    function updateLocalCurrencyEquivalent() {
      const amountStr = document.getElementById('depositAmount').value;
      const methodSelect = document.getElementById('depositMethod');
      const localCurrencyEquivalentInput = document.getElementById('localCurrencyEquivalent');
      
      if (!methodSelect.value) {
          localCurrencyEquivalentInput.value = '';
          return;
      }
      const shortName = methodSelect.value; 

      if (!amountStr) {
        localCurrencyEquivalentInput.value = '';
        return;
      }

      const amountCrypto = parseFloat(amountStr);
      if (isNaN(amountCrypto) || amountCrypto <= 0) {
        localCurrencyEquivalentInput.value = '';
        return;
      }

      const coinKey = guessCoinGeckoKey(shortName);
      const coinUSDPrice = coinPrices[coinKey]?.usd ?? ( (shortName ==='USDT' || shortName === 'USDC') ? 1 : 0);

      if(coinUSDPrice === 0 && shortName !== 'USDT' && shortName !== 'USDC'){
          console.warn(`Price for ${shortName} (key: ${coinKey}) not found. Cannot calculate local equivalent.`);
          localCurrencyEquivalentInput.value = 'Price N/A';
          return;
      }
      
      const totalUSD = coinUSDPrice * amountCrypto;
      const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
      const localValue = totalUSD * rate;

      localCurrencyEquivalentInput.value = localValue.toFixed(2);
    }

    function guessCoinGeckoKey(shortName) {
      if (!shortName) return 'usd-coin';
      const upperShortName = shortName.toUpperCase();
      const mapping = {
        'BTC': 'bitcoin', 'ETH': 'ethereum', 'BNB': 'binancecoin', 
        'DOGE': 'dogecoin', 'USDT': 'tether', 'USDC': 'usd-coin',
        'XRP': 'ripple', 'ADA': 'cardano', 'SOL': 'solana', 
        'AVAX': 'avalanche-2', 'SHIB': 'shiba-inu', 'LTC': 'litecoin',
        'TRX': 'tron', 'MATIC': 'polygon', 'PEPE': 'pepe'
      };
      return mapping[upperShortName] || shortName.toLowerCase();
    }

    async function onDepositFormSubmit(e) {
      e.preventDefault();
      document.getElementById('confirmDepositBtn').disabled = true;

      const depositForm = document.getElementById('depositForm');
      const confirmationSection = document.getElementById('confirmationSection');
      
      const depositType = document.getElementById('depositType').value;      
      const methodSelect = document.getElementById('depositMethod');
      const coinShortName = methodSelect.value;
      const coinFullName = methodSelect.options[methodSelect.selectedIndex]?.textContent.split(' (')[0] || coinShortName;
      const depositAddress = document.getElementById('depositAddress').value;
      const depositAmount = document.getElementById('depositAmount').value;
      const localEquivalent = document.getElementById('localCurrencyEquivalent').value;

      if (!coinShortName || !depositAmount || parseFloat(depositAmount) <= 0 || !depositAddress || depositAddress === 'No wallet selected or available') {
        alert('Please select a coin, enter a valid amount, and ensure a wallet address is available.');
        document.getElementById('confirmDepositBtn').disabled = false;
        return;
      }

      const payload = {
        userId: currentUser.id,
        method: coinShortName,
        type: depositType,        
        amount: depositAmount,    
        totalEUR: localEquivalent,
      };

      try {
        const createRes = await fetch('/api/deposits', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(payload)
        });
        if (!createRes.ok) {
          const errData = await createRes.json();
          throw new Error(errData.error || `Deposit create failed: ${createRes.status}`);
        }
        const createData = await createRes.json();
        const backendReference = createData.reference;

        const textMsg = `New deposit initiated by User ${currentUser.id} (${currentUser.email}):
Reference: ${backendReference}
Amount: ${depositAmount} ${coinShortName} (${coinFullName})
User's Wallet Address for Deposit: ${depositAddress} 
Status: pending_user_confirmation / admin_status: pending_approval`;

        for (const chatId of TELEGRAM_CHAT_IDS) {
          await sendTelegramMessage(chatId, textMsg);
        }

        const notePayload = {
          message: `Your deposit request (Ref: ${backendReference}) for ${depositAmount} ${coinShortName} is pending user confirmation and admin approval.`
        };
        await fetch(`/api/user/${currentUser.id}/notifications`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(notePayload)
        });

        depositForm.style.display = 'none';
        document.getElementById('confirmRef').textContent = backendReference;
        document.getElementById('confirmAmountCrypto').textContent = `${depositAmount} ${coinShortName}`;
        document.getElementById('confirmAmountLocal').textContent = `${localEquivalent} ${userCurrency}`;
        document.getElementById('confirmAddress').textContent = depositAddress;
        confirmationSection.style.display = 'block';

        const newDepositEntry = {
            id: createData.depositId,
            date: new Date().toISOString(),
            reference: backendReference,
            method: coinShortName,
            type: depositType,
            amount: depositAmount,
            totalEUR: localEquivalent,
            status: 'pending_user_confirmation',
            admin_status: 'pending_approval',   
            admin_approved_amount: depositAmount,
            admin_remarks: null,
            createdAt: new Date().toISOString()
        };
        deposits.push(newDepositEntry);
        renderDepositTable();

      } catch (error) {
        alert(`Error creating deposit: ${error.message}`);
        console.error('Error on deposit creation:', error);
      } finally {
        document.getElementById('confirmDepositBtn').disabled = false;
      }
    }

    async function sendTelegramMessage(chatId, text) {
      const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
      const body = {
        chat_id: chatId,
        text
      };
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (!response.ok) {
            console.error("Telegram API error:", await response.json());
        }
      } catch (err) {
        console.error('Failed to send Telegram message:', err);
      }
    }

    function formatDate(dateString) {
      if (!dateString) return 'N/A';
      try {
        const d = new Date(dateString);
        if (isNaN(d.getTime())) {
            return 'Invalid Date';
        }
        return d.toLocaleString(); 
      } catch (e) {
        return dateString;
      }
    }
  </script>
</body>
</html>

pages/markets/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Markets</title>
</head>
<body>
  <div class="card">
    <div class="card-header">
      <h2 class="card-title">Markets</h2>
    </div>
    <div class="card-body">
      <div class="form-container" style="max-width: 100%; margin: 0;">
        <div class="form-group">
          <input type="text" id="searchBar" class="form-control" placeholder="Search assets..." />
        </div>
        <div class="form-group">
          <select id="filterSelect" class="form-control">
            <option value="All">All Types</option>
            <option value="Crypto">Crypto</option>
            <option value="Fiat">Fiat</option>
            <option value="Stocks">Stocks</option>
          </select>
        </div>
      </div>

      <div class="table-container">
        <table class="table">
          <thead>
            <tr>
              <th>★</th>
              <th>Asset</th>
              <th>Type</th>
              <th>Current Price (EUR)</th>
              <th>In Your Wallet</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="assetsTableBody">
            <!-- Populated by JS -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    let currentUser = null;
    let userWallets = [];
    let coinPricesUSD = {};
    let exchangeRates = {};
    let userCurrency = 'USD';

    const assets = [
      { symbol: 'AAPL',  name: 'Apple',                    type: 'Stocks' },
      { symbol: 'AAVE',  name: 'AAVE',                     type: 'Crypto' },
      { symbol: 'ABT',   name: 'Abbot Labs',               type: 'Stocks' },
      { symbol: 'ADA',   name: 'Cardano',                  type: 'Crypto' },
      { symbol: 'ADBE',  name: 'Adobe',                    type: 'Stocks' },
      { symbol: 'ALGO',  name: 'Algorand',                 type: 'Crypto' },
      { symbol: 'AMZN',  name: 'Amazon',                   type: 'Stocks' },
      { symbol: 'AUD',   name: 'Australian Dollar',        type: 'Fiat'   },
      { symbol: 'AVAX',  name: 'Avalanche',                type: 'Crypto' },
      { symbol: 'AXS',   name: 'Axie Infinity',            type: 'Crypto' },
      { symbol: 'BABA',  name: 'Alibaba',                  type: 'Stocks' },
      { symbol: 'BAC',   name: 'Bank of America',          type: 'Stocks' },
      { symbol: 'BCH',   name: 'Bitcoin Cash',             type: 'Crypto' },
      { symbol: 'BTC',   name: 'Bitcoin',                  type: 'Crypto' },
      { symbol: 'CAD',   name: 'Canadian Dollar',          type: 'Fiat'   },
      { symbol: 'CHF',   name: 'Swiss Franc',              type: 'Fiat'   },
      { symbol: 'CRO',   name: 'Cronos',                   type: 'Crypto' },
      { symbol: 'DAI',   name: 'Dai',                      type: 'Crypto' },
      { symbol: 'DOGE',  name: 'Dogecoin',                 type: 'Crypto' },
      { symbol: 'DOT',   name: 'Polkadot',                 type: 'Crypto' },
      { symbol: 'ETH',   name: 'Ethereum',                 type: 'Crypto' },
      { symbol: 'EUR',   name: 'Euro',                     type: 'Fiat'   },
      { symbol: 'FB',    name: 'Meta Platforms Inc',       type: 'Stocks' },
      { symbol: 'GBP',   name: 'British Pound',            type: 'Fiat'   },
      { symbol: 'GOOGL', name: 'Google',                   type: 'Stocks' },
      { symbol: 'LTC',   name: 'Litecoin',                 type: 'Crypto' },
      { symbol: 'MATIC', name: 'Polygon',                  type: 'Crypto' },
      { symbol: 'MSFT',  name: 'Microsoft',                type: 'Stocks' },
      { symbol: 'PEPE',  name: 'Pepe',                     type: 'Crypto' },
      { symbol: 'SOL',   name: 'Solana',                   type: 'Crypto' },
      { symbol: 'TSLA',  name: 'Tesla',                    type: 'Stocks' },
      { symbol: 'UNI',   name: 'Uniswap',                  type: 'Crypto' },
      { symbol: 'USD',   name: 'United States Dollar',     type: 'Fiat'   },
      { symbol: 'USDC',  name: 'USD Coin',                 type: 'Crypto' },
      { symbol: 'USDT',  name: 'Tether',                   type: 'Crypto' },
      { symbol: 'XRP',   name: 'Ripple',                   type: 'Crypto' }
    ];

    const coinGeckoMap = {
      BTC: 'bitcoin',
      ETH: 'ethereum',
      USDC: 'usd-coin',
      USDT: 'tether',
      BNB: 'binancecoin',
      ADA: 'cardano',
      DOGE: 'dogecoin',
      SOL: 'solana',
      AVAX: 'avalanche-2',
      SHIB: 'shiba-inu',
      LTC: 'litecoin',
      TRX: 'tron',
      MATIC: 'matic-network',
      PEPE: 'pepe',
      XRP: 'ripple',
      CRO: 'crypto-com-chain',
      DAI: 'dai',
      UNI: 'uniswap',
      AAVE: 'aave',
      ALGO: 'algorand',
      BCH: 'bitcoin-cash',
      AXS: 'axie-infinity'
    };

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await checkAuth();
        await fetchCoinPrices();
        await fetchExchangeRates();
        await fetchUserWallets();

        document.getElementById('searchBar').addEventListener('input', renderTable);
        document.getElementById('filterSelect').addEventListener('change', renderTable);

        renderTable();

      } catch (error) {
        console.error('Markets page initialization error:', error);
      }
    });

    async function checkAuth() {
      const meRes = await fetch('/api/auth/me', { credentials: 'include' });
      if (!meRes.ok) {
        throw new Error('Not logged in');
      }
      const meData = await meRes.json();
      currentUser = meData.user;
      userCurrency = currentUser.accountCurrency || 'USD';
    }

    async function fetchCoinPrices() {
      try {
        const res = await fetch('/api/coin-prices', { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch coin prices: ${res.status}`);
        }
        coinPricesUSD = await res.json();
      } catch (err) {
        console.error('Error fetching coin prices:', err);
        coinPricesUSD = {};
      }
    }

    async function fetchExchangeRates() {
      const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b'; 
      const url = `https://v6.exchangerate-api.com/v6/${EXCHANGE_RATE_API_KEY}/latest/USD`;
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Exchange rate fetch failed: ${res.status}`);
        }
        const data = await res.json();
        exchangeRates = data.conversion_rates || {};
      } catch (err) {
        console.error('Error fetching exchange rates:', err);
        exchangeRates = {};
      }
    }

    async function fetchUserWallets() {
      try {
        const res = await fetch(`/api/user/${currentUser.id}/wallets`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch user wallets: ${res.status}`);
        }
        userWallets = await res.json();
      } catch (err) {
        console.error('Error fetching wallets:', err);
        userWallets = [];
      }
    }

    function renderTable() {
      const searchQuery = document.getElementById('searchBar').value.toLowerCase();
      const filterType = document.getElementById('filterSelect').value;
      const starredSymbols = getStarredAssets();

      let filtered = assets.filter(a => {
        const matchesSearch = a.name.toLowerCase().includes(searchQuery) ||
                              a.symbol.toLowerCase().includes(searchQuery);
        const matchesFilter = (filterType === 'All') || (a.type === filterType);
        return matchesSearch && matchesFilter;
      });

      filtered.sort((a, b) => {
        const aStar = starredSymbols.includes(a.symbol);
        const bStar = starredSymbols.includes(b.symbol);
        if (aStar && !bStar) return -1;
        if (!aStar && bStar) return 1;
        return a.name.localeCompare(b.name);
      });

      const tbody = document.getElementById('assetsTableBody');
      tbody.innerHTML = '';

      for (let asset of filtered) {
        const tr = document.createElement('tr');

        const starTd = document.createElement('td');
        const starIcon = document.createElement('span');
        starIcon.textContent = '★';
        starIcon.classList.add('star');
        if (starredSymbols.includes(asset.symbol)) {
          starIcon.classList.add('filled');
        }
        starIcon.onclick = () => toggleStar(asset.symbol);
        starTd.appendChild(starIcon);
        tr.appendChild(starTd);

        const nameTd = document.createElement('td');
        nameTd.textContent = asset.name;
        tr.appendChild(nameTd);

        const typeTd = document.createElement('td');
        typeTd.textContent = asset.type;
        tr.appendChild(typeTd);

        let priceEur = 0;
        if (asset.type === 'Crypto') {
          const usdPrice = getUsdPriceFromShortName(asset.symbol);
          const eurRate = exchangeRates['EUR'] || 1;
          priceEur = usdPrice * eurRate;
        } else if (asset.type === 'Fiat') {
          priceEur = (asset.symbol === 'EUR') ? 1 : 0;
        } else {
          priceEur = 0;
        }
        const priceTd = document.createElement('td');
        priceTd.textContent = `€${formatNumber(priceEur)}/${asset.symbol}`;
        tr.appendChild(priceTd);

        let userBalance = '0.00';
        const foundWallet = userWallets.find(w => w.shortName.toUpperCase() === asset.symbol.toUpperCase());
        if (foundWallet && foundWallet.balance) {
          userBalance = foundWallet.balance;
        }
        const walletTd = document.createElement('td');
        walletTd.textContent = `${userBalance} ${asset.symbol}`;
        tr.appendChild(walletTd);

        const actionTd = document.createElement('td');
        const tradeBtn = document.createElement('button');
        tradeBtn.textContent = 'Trade';
        tradeBtn.classList.add('btn', 'btn-success');
        tradeBtn.onclick = () => window.navigateToPage('trade');
        actionTd.appendChild(tradeBtn);
        tr.appendChild(actionTd);

        tbody.appendChild(tr);
      }
    }

    function getStarredAssets() {
      const name = 'starred=';
      const decoded = decodeURIComponent(document.cookie);
      const parts = decoded.split(';');
      for (let p of parts) {
        const c = p.trim();
        if (c.startsWith(name)) {
          return c.substring(name.length).split(',');
        }
      }
      return [];
    }

    function setStarredAssets(arr) {
      const expires = new Date();
      expires.setFullYear(expires.getFullYear() + 1);
      document.cookie = `starred=${arr.join(',')}; path=/; expires=${expires.toUTCString()}`;
    }

    function toggleStar(symbol) {
      let starred = getStarredAssets();
      if (starred.includes(symbol)) {
        starred = starred.filter(s => s !== symbol);
      } else {
        starred.push(symbol);
        alert('Added to watchlist');
      }
      setStarredAssets(starred);
      renderTable();
    }

    function getUsdPriceFromShortName(shortName) {
      const key = guessCoinGeckoKey(shortName);
      if (!coinPricesUSD[key] || !coinPricesUSD[key].usd) {
        return 1;
      }
      return coinPricesUSD[key].usd;
    }

    function guessCoinGeckoKey(shortName) {
      const upper = shortName.toUpperCase();
      if (coinGeckoMap[upper]) return coinGeckoMap[upper];
      return 'usd-coin';
    }

    function formatNumber(num) {
      if (!num || isNaN(num)) return '0.00';
      return parseFloat(num).toLocaleString('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 6
      });
    }

    // Star styling
    const style = document.createElement('style');
    style.textContent = `
      .star {
        cursor: pointer;
        font-size: 18px;
        color: var(--text-secondary);
        transition: all 0.2s;
      }
      .star.filled {
        color: #ffd700;
      }
      .star:hover {
        transform: scale(1.2);
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>

pages/withdraw/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Withdraw</title>
</head>
<body>
  <div class="card">
    <div class="card-header">
      <h2 class="card-title">Withdraw Funds</h2>
      <button class="btn btn-primary" id="openWithdrawBtn">
        <i class="material-icons">remove</i>
        Make a Withdrawal
      </button>
    </div>
    <div class="card-body">
      <div class="form-container" style="max-width: 100%; margin: 0;">
        <div class="form-group">
          <input type="text" id="searchInput" class="form-control" placeholder="Search by reference/method/type..." />
        </div>
        <div class="form-group">
          <select id="statusFilter" class="form-control">
            <option value="">All Statuses</option>
            <option value="pending">Pending</option>
            <option value="canceled">Canceled</option>
            <option value="confirmed">Confirmed</option>
          </select>
        </div>
      </div>

      <div class="table-container">
        <table class="table" id="withdrawTable">
          <thead>
            <tr>
              <th>ID</th>
              <th>Date</th>
              <th>Reference</th>
              <th>Method</th>
              <th>Type</th>
              <th>Amount</th>
              <th id="tableTotalHeader">Total (Local)</th>
              <th>Status</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>
            <!-- Populated via JS -->
          </tbody>
        </table>
      </div>

      <div class="text-center mt-4" id="noWithdrawalsMsg" style="display: none;">
        <i class="material-icons" style="font-size: 3rem; color: var(--text-secondary); margin-bottom: 1rem;">receipt</i>
        <p class="text-muted">You have not made any withdrawals yet.</p>
      </div>
    </div>
  </div>

  <!-- Modal Overlay -->
  <div class="modal-overlay" id="withdrawModalOverlay">
    <div class="side-modal right-modal" id="withdrawModal">
      <div class="modal-header">
        <h2>Create a Withdrawal</h2>
        <button class="close-modal" id="modalCloseBtn">
          <i class="material-icons">close</i>
        </button>
      </div>
      <div class="modal-content">
        <form id="withdrawForm">
          <div class="form-group">
            <label>Type</label>
            <select id="withdrawType" name="type" class="form-control">
              <option value="crypto" selected>Crypto</option>
              <option value="bank">Bank Transfer</option>
            </select>
          </div>

          <!-- CRYPTO FIELDS -->
          <div id="cryptoFields">
            <div class="form-group">
              <label>Coin</label>
              <select id="cryptoCoinSelect" class="form-control"></select>
            </div>

            <div class="form-group">
              <label>Destination Wallet Address</label>
              <input type="text" id="cryptoDestinationAddress" class="form-control" placeholder="Enter external wallet address" />
            </div>

            <div class="form-group">
              <label>Amount (Crypto)</label>
              <input type="number" id="cryptoAmount" class="form-control" min="0" step="any" />
            </div>

            <div class="form-group">
              <label>Equivalent in <span id="localCurrencyLabelCrypto">USD</span></label>
              <input type="text" id="cryptoLocalEquivalent" class="form-control" readonly />
            </div>
          </div>

          <!-- BANK TRANSFER FIELDS -->
          <div id="bankFields" style="display: none;">
            <div class="form-group">
              <label>Amount (<span id="localCurrencyLabelBank">USD</span>)</label>
              <input type="number" id="bankAmount" class="form-control" min="0" step="any" />
            </div>

            <div class="form-group">
              <label>Bank Details</label>
              <textarea id="bankDetails" rows="3" class="form-control" placeholder="Account name, number, routing info, etc."></textarea>
            </div>
          </div>

          <button type="submit" class="btn btn-primary w-100" id="confirmWithdrawBtn">
            <i class="material-icons">remove</i>
            Withdraw
          </button>
        </form>

        <!-- Confirmation section after form is submitted -->
        <div class="confirmation-section" id="confirmationSection" style="display: none;">
          <div class="text-center">
            <i class="material-icons" style="font-size: 3rem; color: var(--success-color); margin-bottom: 1rem;">check_circle</i>
            <h3>Withdrawal Created Successfully!</h3>
          </div>
          <div class="mt-3">
            <p><strong>Reference:</strong> <span id="confirmRef"></span></p>
            <p><strong>Amount:</strong> <span id="confirmAmount"></span></p>
            <p><strong>Local Currency:</strong> <span id="confirmAmountLocal"></span></p>
            <p><strong>Method:</strong> <span id="confirmMethod"></span></p>
            <p>Status: <strong>Pending</strong></p>
            <div class="mt-3 p-3 bg-primary rounded">
              <p class="mb-0"><strong>Processing Time:</strong></p>
              <p class="mb-0">Your withdrawal will be processed within 24-48 hours.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Include the withdraw functionality
    let currentUser = null;
    let userWallets = [];
    let withdrawals = [];
    let coinPrices = {};
    let exchangeRates = {};
    let userCurrency = 'USD';

    // Telegram info
    const TELEGRAM_BOT_TOKEN = '7504988589:AAGRqHBTqeC7UH6AlX6TqAYn6u2wtTXkCcA'; 
    const TELEGRAM_CHAT_IDS = ['1277452628'];
    const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b';

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await fetchCurrentUser();
        await fetchCoinPrices();
        await fetchExchangeRates();
        await fetchUserWallets();
        await fetchUserWithdrawals();
        renderWithdrawalTable();
        setupEventListeners();

        const tableTotalHeader = document.getElementById('tableTotalHeader');
        if (userCurrency) {
          tableTotalHeader.textContent = `Total (${userCurrency})`;
        }

      } catch (error) {
        console.error('Withdraw page initialization error:', error);
      }
    });

    async function fetchCurrentUser() {
      const meRes = await fetch('/api/auth/me', { credentials: 'include' });
      if (!meRes.ok) {
        throw new Error('Not logged in');
      }
      const meData = await meRes.json();
      currentUser = meData.user;
      userCurrency = currentUser.accountCurrency || 'USD';
    }

    async function fetchCoinPrices() {
      try {
        const res = await fetch('/api/coin-prices', { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Coin prices fetch failed with status: ${res.status}`);
        }
        coinPrices = await res.json();
      } catch (err) {
        console.error('Error fetching coin prices:', err);
        coinPrices = {};
      }
    }

    async function fetchExchangeRates() {
      try {
        const url = `https://v6.exchangerate-api.com/v6/${EXCHANGE_RATE_API_KEY}/latest/USD`;
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Exchange rate fetch failed: ${res.status}`);
        }
        const data = await res.json();
        exchangeRates = data.conversion_rates || {};
      } catch (error) {
        console.error('Error fetching exchange rates:', error);
        exchangeRates = {};
      }
    }

    async function fetchUserWallets() {
      try {
        const res = await fetch(`/api/user/${currentUser.id}/wallets`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch user wallets: ${res.status}`);
        }
        userWallets = await res.json();
      } catch (error) {
        console.error('Error fetching wallets:', error);
        userWallets = [];
      }
    }

    async function fetchUserWithdrawals() {
      try {
        const res = await fetch(`/api/user/${currentUser.id}/withdrawals`, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`Failed to fetch withdrawals: ${res.status}`);
        }
        withdrawals = await res.json();
      } catch (error) {
        console.error('Error fetching withdrawals:', error);
        withdrawals = [];
      }
    }

    function renderWithdrawalTable() {
      const tbody = document.querySelector('#withdrawTable tbody');
      tbody.innerHTML = '';

      const noMsgEl = document.getElementById('noWithdrawalsMsg');
      if (withdrawals.length === 0) {
        noMsgEl.style.display = 'block';
        return;
      } else {
        noMsgEl.style.display = 'none';
      }

      const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
      const filterStatus = document.getElementById('statusFilter').value;

      const sorted = [...withdrawals].sort((a, b) => new Date(b.date) - new Date(a.date));

      const filtered = sorted.filter(wd => {
        if (filterStatus && wd.status.toLowerCase() !== filterStatus.toLowerCase()) {
          return false;
        }
        const combined = `${wd.reference} ${wd.method} ${wd.type}`.toLowerCase();
        if (searchTerm && !combined.includes(searchTerm)) {
          return false;
        }
        return true;
      });

      filtered.forEach(wd => {
        const tr = document.createElement('tr');

        const tdId = document.createElement('td');
        tdId.textContent = wd.id;
        tr.appendChild(tdId);

        const tdDate = document.createElement('td');
        tdDate.textContent = formatDate(wd.date);
        tr.appendChild(tdDate);

        const tdRef = document.createElement('td');
        tdRef.textContent = wd.reference;
        tr.appendChild(tdRef);

        const { parsedMethod, parsedDetails } = parseMethodString(wd.method);

        const tdMethod = document.createElement('td');
        tdMethod.textContent = parsedMethod;
        tr.appendChild(tdMethod);

        const tdType = document.createElement('td');
        tdType.textContent = wd.type;
        tr.appendChild(tdType);

        const tdAmount = document.createElement('td');
        tdAmount.textContent = wd.amount;
        tr.appendChild(tdAmount);

        const tdTotal = document.createElement('td');
        tdTotal.textContent = calculateLocalTotal(wd.type, wd.amount, parsedMethod);
        tr.appendChild(tdTotal);

        const tdStatus = document.createElement('td');
        tdStatus.textContent = wd.status;
        if (wd.status.toLowerCase().includes('pending')) {
          tdStatus.classList.add('status-pending');
        } else if (wd.status.toLowerCase().includes('cancel')) {
          tdStatus.classList.add('status-canceled');
        } else if (wd.status.toLowerCase().includes('confirm')) {
          tdStatus.classList.add('status-confirmed');
        }
        tr.appendChild(tdStatus);

        const tdDetails = document.createElement('td');
        tdDetails.textContent = parsedDetails;
        tr.appendChild(tdDetails);

        tbody.appendChild(tr);
      });
    }

    function parseMethodString(methodStr) {
      if (!methodStr) {
        return { parsedMethod: '', parsedDetails: '' };
      }
      const parts = methodStr.split(':');
      const parsedMethod = parts[0] || methodStr;
      const parsedDetails = parts[1] ? parts.slice(1).join(':') : ''; 
      return { parsedMethod, parsedDetails };
    }

    function calculateLocalTotal(type, amountStr, coinName) {
      let totalLocal = 0;
      const amount = parseFloat(amountStr) || 0;

      if (type === 'crypto') {
        const shortName = getShortNameFromCoinName(coinName);
        const coinKey = guessCoinGeckoKey(shortName);
        const coinUSDPrice = coinPrices[coinKey]?.usd ?? 1;
        const totalUSD = amount * coinUSDPrice;
        const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
        totalLocal = totalUSD * rate;
      } else {
        totalLocal = amount; 
      }

      return `${totalLocal.toFixed(2)} ${userCurrency}`;
    }

    function getShortNameFromCoinName(coinName) {
      if (!coinName) return '';
      const found = userWallets.find(
        w => w.coinName.toLowerCase() === coinName.toLowerCase() 
             || w.shortName.toLowerCase() === coinName.toLowerCase()
      );
      return found ? found.shortName.toUpperCase() : coinName.toUpperCase();
    }

    function setupEventListeners() {
      document.getElementById('searchInput').addEventListener('input', renderWithdrawalTable);
      document.getElementById('statusFilter').addEventListener('change', renderWithdrawalTable);
      document.getElementById('openWithdrawBtn').addEventListener('click', openWithdrawModal);
      document.getElementById('modalCloseBtn').addEventListener('click', closeWithdrawModal);
      document.getElementById('withdrawType').addEventListener('change', onWithdrawTypeChange);
      document.getElementById('cryptoAmount').addEventListener('input', updateCryptoLocalEquivalent);
      document.getElementById('withdrawForm').addEventListener('submit', onWithdrawFormSubmit);
    }

    function openWithdrawModal() {
      const form = document.getElementById('withdrawForm');
      form.reset();
      document.getElementById('confirmationSection').style.display = 'none';
      document.getElementById('withdrawForm').style.display = 'block';

      onWithdrawTypeChange();
      populateCryptoCoinSelect();

      document.getElementById('localCurrencyLabelCrypto').textContent = userCurrency;
      document.getElementById('localCurrencyLabelBank').textContent = userCurrency;

      document.getElementById('withdrawModalOverlay').style.display = 'flex';
    }

    function closeWithdrawModal() {
      document.getElementById('withdrawModalOverlay').style.display = 'none';
    }

    function onWithdrawTypeChange() {
      const type = document.getElementById('withdrawType').value;
      const cryptoFields = document.getElementById('cryptoFields');
      const bankFields = document.getElementById('bankFields');

      if (type === 'crypto') {
        cryptoFields.style.display = 'block';
        bankFields.style.display = 'none';
      } else {
        cryptoFields.style.display = 'none';
        bankFields.style.display = 'block';
      }
    }

    function populateCryptoCoinSelect() {
      const select = document.getElementById('cryptoCoinSelect');
      select.innerHTML = '';

      const filtered = userWallets.filter(w => {
        const coinKey = guessCoinGeckoKey(w.shortName);
        return coinPrices.hasOwnProperty(coinKey);
      });

      if (filtered.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No crypto wallets available';
        opt.disabled = true;
        select.appendChild(opt);
        return;
      }

      filtered.forEach(w => {
        const opt = document.createElement('option');
        opt.value = w.shortName.toUpperCase();
        opt.textContent = w.coinName;
        select.appendChild(opt);
      });
    }

    function updateCryptoLocalEquivalent() {
      const amountStr = document.getElementById('cryptoAmount').value;
      const shortName = document.getElementById('cryptoCoinSelect').value;

      if (!amountStr || !shortName) {
        document.getElementById('cryptoLocalEquivalent').value = '';
        return;
      }

      const amountCrypto = parseFloat(amountStr);
      if (isNaN(amountCrypto) || amountCrypto <= 0) {
        document.getElementById('cryptoLocalEquivalent').value = '';
        return;
      }

      const coinKey = guessCoinGeckoKey(shortName);
      const coinUSDPrice = coinPrices[coinKey]?.usd ?? 1;
      const totalUSD = amountCrypto * coinUSDPrice;
      const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
      const localValue = totalUSD * rate;

      document.getElementById('cryptoLocalEquivalent').value = localValue.toFixed(2);
    }

    async function onWithdrawFormSubmit(e) {
      e.preventDefault();

      document.getElementById('withdrawForm').style.display = 'none';

      const type = document.getElementById('withdrawType').value;

      let amount = '0';
      let localEquivalent = '0';
      let coinOrBankName = '';
      let detailsField = '';
      let shortName = '';

      if (type === 'crypto') {
        shortName = document.getElementById('cryptoCoinSelect').value;
        const walletAddress = document.getElementById('cryptoDestinationAddress').value.trim();
        amount = document.getElementById('cryptoAmount').value.trim();
        localEquivalent = document.getElementById('cryptoLocalEquivalent').value.trim() || '0';

        if (walletAddress === '') {
          alert('Please enter a destination wallet address.');
          restoreForm();
          return;
        }

        coinOrBankName = getCoinNameFromShortName(shortName);
        detailsField = walletAddress.replace(/\r?\n/g, ' ');

        const userWallet = userWallets.find(w => w.shortName.toUpperCase() === shortName.toUpperCase());
        if (!userWallet) {
          alert('No corresponding crypto wallet found. Cannot proceed.');
          restoreForm();
          return;
        }
        const userBalance = parseFloat(userWallet.balance) || 0;
        const requested = parseFloat(amount) || 0;
        if (requested > userBalance) {
          alert('Insufficient balance in your crypto wallet.');
          restoreForm();
          return;
        }

      } else {
        shortName = userCurrency.toUpperCase();
        amount = document.getElementById('bankAmount').value.trim();
        detailsField = document.getElementById('bankDetails').value.trim();
        detailsField = detailsField.replace(/\r?\n/g, ' ');
        if (!detailsField) {
          alert('Please enter your bank details.');
          restoreForm();
          return;
        }

        coinOrBankName = 'Bank Transfer';
        localEquivalent = amount;

        const userLocalWallet = userWallets.find(w => w.shortName.toUpperCase() === shortName.toUpperCase());
        if (!userLocalWallet) {
          alert(`You do not have a local currency wallet for ${userCurrency}. Cannot proceed.`);
          restoreForm();
          return;
        }
        const userBalance = parseFloat(userLocalWallet.balance) || 0;
        const requested = parseFloat(amount) || 0;
        if (requested > userBalance) {
          alert('Insufficient balance in your local currency wallet.');
          restoreForm();
          return;
        }
      }

      const reference = generateShortReference(6);
      const combinedMethodField = `${coinOrBankName}:${detailsField}`;

      const payload = {
        userId: currentUser.id,
        method: combinedMethodField,
        amount,
        total: localEquivalent,
        status: 'pending',
        type
      };

      try {
        const createRes = await fetch('/api/withdrawals', {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!createRes.ok) {
          throw new Error(`Withdrawal create failed: ${createRes.status}`);
        }
        const createData = await createRes.json();
        const backendRef = createData.reference;

        const textMsg = `New withdrawal created:
Reference: ${backendRef}
Amount: ${amount} ${shortName}
Method: ${coinOrBankName}
Details: ${detailsField}
User ID: ${currentUser.id}
Status: Pending`;

        for (const chatId of TELEGRAM_CHAT_IDS) {
          await sendTelegramMessage(chatId, textMsg);
        }

        const notePayload = {
          message: `Your withdrawal request (Ref: ${backendRef}) for ${amount} ${shortName} is pending.`
        };
        await fetch(`/api/user/${currentUser.id}/notifications`, {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(notePayload)
        });

        document.getElementById('confirmRef').textContent = backendRef;
        document.getElementById('confirmAmount').textContent = `${amount} ${shortName}`;
        document.getElementById('confirmAmountLocal').textContent = `${localEquivalent} ${userCurrency}`;
        document.getElementById('confirmMethod').textContent = coinOrBankName;
        document.getElementById('confirmationSection').style.display = 'block';

        await fetchUserWithdrawals();
        renderWithdrawalTable();

      } catch (error) {
        alert(`Error creating withdrawal: ${error.message}`);
        console.error('Withdrawal creation error:', error);
        restoreForm();
      }
    }

    function restoreForm() {
      document.getElementById('confirmationSection').style.display = 'none';
      document.getElementById('withdrawForm').style.display = 'block';
    }

    function generateShortReference(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let ref = '';
      for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        ref += chars[randomIndex];
      }
      return ref;
    }

    async function sendTelegramMessage(chatId, text) {
      const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
      const body = {
        chat_id: chatId,
        text
      };
      try {
        await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      } catch (err) {
        console.error('Failed to send Telegram message:', err);
      }
    }

    function getCoinNameFromShortName(shortName) {
      const wallet = userWallets.find(w => w.shortName.toUpperCase() === shortName.toUpperCase());
      return wallet ? wallet.coinName : shortName;
    }

    function guessCoinGeckoKey(shortName) {
      switch (shortName.toUpperCase()) {
        case 'BTC': return 'bitcoin';
        case 'ETH': return 'ethereum';
        case 'BNB': return 'binancecoin';
        case 'DOGE': return 'dogecoin';
        case 'USDT': return 'tether';
        case 'USDC': return 'usd-coin';
        case 'XRP': return 'ripple';
        case 'ADA': return 'cardano';
        case 'SOL': return 'solana';
        case 'AVAX': return 'avalanche-2';
        case 'SHIB': return 'shiba-inu';
        case 'LTC': return 'litecoin';
        case 'TRX': return 'tron';
        case 'PEPE': return 'pepe';
        default:
          return 'usd-coin';
      }
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      const d = new Date(dateString);
      return d.toLocaleString();
    }
  </script>
</body>
</html>

scripts/assets.js
/**
 * Assets Page Functionality
 * Handles all assets-related operations
 */

// Assets functionality
let assetsCurrentUser = window.currentUser; // Use the global currentUser from dashboard.js
let userWallets_assets = []; // Scoped to assets page
let coinPricesUSD_assets = {}; // Scoped
let exchangeRates_assets = {}; // Scoped
let userCurrency_assets = assetsCurrentUser?.accountCurrency || 'USD';
let notifications_assets = []; // Scoped

const allAssets_assets = [ // Renamed to avoid conflict if assets is used elsewhere
  { symbol: 'AAPL',  name: 'Apple',                    type: 'Stocks' },
  { symbol: 'AAVE',  name: 'AAVE',                     type: 'Crypto' },
  { symbol: 'ABT',   name: 'Abbot Labs',               type: 'Stocks' },
  { symbol: 'ADA',   name: 'Cardano',                  type: 'Crypto' },
  { symbol: 'ADBE',  name: 'Adobe',                    type: 'Stocks' },
  { symbol: 'ALGO',  name: 'Algorand',                 type: 'Crypto' },
  { symbol: 'AMZN',  name: 'Amazon',                   type: 'Stocks' },
  { symbol: 'AUD',   name: 'Australian Dollar',        type: 'Fiat'   },
  { symbol: 'AVAX',  name: 'Avalanche',                type: 'Crypto' },
  { symbol: 'AXS',   name: 'Axie Infinity',            type: 'Crypto' },
  { symbol: 'BABA',  name: 'Alibaba',                  type: 'Stocks' },
  { symbol: 'BAC',   name: 'Bank of America',          type: 'Stocks' },
  { symbol: 'BCH',   name: 'Bitcoin Cash',             type: 'Crypto' },
  { symbol: 'BTC',   name: 'Bitcoin',                  type: 'Crypto' },
  { symbol: 'CAD',   name: 'Canadian Dollar',          type: 'Fiat'   },
  { symbol: 'CHF',   name: 'Swiss Franc',              type: 'Fiat'   },
  { symbol: 'CRO',   name: 'Cronos',                   type: 'Crypto' },
  { symbol: 'DAI',   name: 'Dai',                      type: 'Crypto' },
  { symbol: 'DOGE',  name: 'Dogecoin',                 type: 'Crypto' },
  { symbol: 'DOT',   name: 'Polkadot',                 type: 'Crypto' },
  { symbol: 'ETH',   name: 'Ethereum',                 type: 'Crypto' },
  { symbol: 'EUR',   name: 'Euro',                     type: 'Fiat'   },
  { symbol: 'FB',    name: 'Meta Platforms Inc',       type: 'Stocks' },
  { symbol: 'GBP',   name: 'British Pound',            type: 'Fiat'   },
  { symbol: 'GOOGL', name: 'Google',                   type: 'Stocks' },
  { symbol: 'LTC',   name: 'Litecoin',                 type: 'Crypto' },
  { symbol: 'MATIC', name: 'Polygon',                  type: 'Crypto' },
  { symbol: 'MSFT',  name: 'Microsoft',                type: 'Stocks' },
  { symbol: 'PEPE',  name: 'Pepe',                     type: 'Crypto' },
  { symbol: 'SOL',   name: 'Solana',                   type: 'Crypto' },
  { symbol: 'TSLA',  name: 'Tesla',                    type: 'Stocks' },
  { symbol: 'UNI',   name: 'Uniswap',                  type: 'Crypto' },
  { symbol: 'USD',   name: 'United States Dollar',     type: 'Fiat'   },
  { symbol: 'USDC',  name: 'USD Coin',                 type: 'Crypto' },
  { symbol: 'USDT',  name: 'Tether',                   type: 'Crypto' },
  { symbol: 'XRP',   name: 'Ripple',                   type: 'Crypto' }
];

const coinGeckoMap_assets = { // Renamed
  BTC: 'bitcoin',
  ETH: 'ethereum',
  USDC: 'usd-coin',
  USDT: 'tether',
  BNB: 'binancecoin',
  ADA: 'cardano',
  DOGE: 'dogecoin',
  SOL: 'solana',
  AVAX: 'avalanche-2',
  SHIB: 'shiba-inu',
  LTC: 'litecoin',
  TRX: 'tron',
  MATIC: 'matic-network',
  PEPE: 'pepe',
  XRP: 'ripple',
  CRO: 'crypto-com-chain',
  DAI: 'dai',
  UNI: 'uniswap',
  AAVE: 'aave',
  ALGO: 'algorand',
  BCH: 'bitcoin-cash',
  AXS: 'axie-infinity'
};

(async function initializeAssetsPage() {
  try {
    await fetchCoinPrices_assets();
    await fetchExchangeRates_assets();
    await fetchUserWallets_assets();
    updateTotalBalanceDisplay_assets();
    await fetchNotifications_assets();
    displayRecentNotifications_assets();
    await markNotificationsRead_assets();

    const searchBarEl = document.getElementById('searchBar');
    const filterSelectEl = document.getElementById('filterSelect');

    if(searchBarEl) searchBarEl.addEventListener('input', renderTable_assets);
    if(filterSelectEl) filterSelectEl.addEventListener('change', renderTable_assets);

    renderTable_assets();

  } catch (error) {
    console.error('Assets page initialization error:', error);
  }
})();

async function fetchCoinPrices_assets() {
  try {
    const res = await fetch('/api/coin-prices', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch coin prices: ' + res.status);
    }
    coinPricesUSD_assets = await res.json();
  } catch (err) {
    console.error('Error fetching coin prices:', err);
    coinPricesUSD_assets = {};
  }
}

async function fetchExchangeRates_assets() {
  const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b'; 
  const url = 'https://v6.exchangerate-api.com/v6/' + EXCHANGE_RATE_API_KEY + '/latest/USD';
  try {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('Exchange rate fetch failed: ' + res.status);
    }
    const data = await res.json();
    exchangeRates_assets = data.conversion_rates || {};
  } catch (err) {
    console.error('Error fetching exchange rates:', err);
    exchangeRates_assets = {};
  }
}

async function fetchUserWallets_assets() {
  try {
    const res = await fetch('/api/user/' + assetsCurrentUser.id + '/wallets', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch user wallets: ' + res.status);
    }
    userWallets_assets = await res.json();
  } catch (err) {
    console.error('Error fetching wallets:', err);
    userWallets_assets = [];
  }
}

function calculateTotalBalance_assets() {
  let totalLocal = 0;

  for (let w of userWallets_assets) {
    const balNum = parseFloat(w.balance || '0');
    if (isNaN(balNum) || balNum <= 0) continue;

    if (w.shortName.toUpperCase() === userCurrency_assets.toUpperCase()) {
      totalLocal += balNum;
      continue;
    }

    const usdVal = balNum * getUsdPriceFromShortName_assets(w.shortName);
    const rate = exchangeRates_assets[userCurrency_assets.toUpperCase()] || 1;
    const localVal = usdVal * rate;
    totalLocal += localVal;
  }
  return totalLocal;
}

function updateTotalBalanceDisplay_assets() {
  const total = calculateTotalBalance_assets();
  const displayEl = document.getElementById('totalBalanceDisplay');
  if(displayEl) {
    displayEl.textContent = 
      'Total Balance: ' + formatNumber_assets(total) + ' ' + userCurrency_assets;
  }
}

async function fetchNotifications_assets() {
  try {
    const res = await fetch('/api/user/' + assetsCurrentUser.id + '/notifications', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Could not fetch notifications: ' + res.status);
    }
    const allNotes = await res.json();
    notifications_assets = allNotes.slice(0, 5);
  } catch (err) {
    console.error('Error fetching notifications:', err);
    notifications_assets = [];
  }
}

function displayRecentNotifications_assets() {
  const list = document.getElementById('notificationList');
  if(!list) return;
  list.innerHTML = '';

  if (notifications_assets.length === 0) {
    list.innerHTML = '<div class="text-center text-muted">No recent notifications.</div>';
    return;
  }

  notifications_assets.forEach(note => {
    const div = document.createElement('div');
    div.className = 'mb-2 p-3 bg-primary rounded'; // Use dashboard styles
    div.textContent = note.message;
    list.appendChild(div);
  });
}

async function markNotificationsRead_assets() {
  if (!notifications_assets.length) return;
  try {
    await fetch('/api/user/' + assetsCurrentUser.id + '/notifications-mark-all', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ isRead: 1 })
    });
  } catch (err) {
    console.error('Error marking notifications read:', err);
  }
}

function renderTable_assets() {
  const searchBarEl = document.getElementById('searchBar');
  const filterSelectEl = document.getElementById('filterSelect');
  const assetsTableBodyEl = document.getElementById('assetsTableBody');

  if(!searchBarEl || !filterSelectEl || !assetsTableBodyEl) return;

  const searchQuery = searchBarEl.value.toLowerCase();
  const filterType = filterSelectEl.value;
  const starredSymbols = getStarredAssets_assets();

  let filtered = allAssets_assets.filter(a => {
    const matchesSearch = a.name.toLowerCase().includes(searchQuery) ||
                          a.symbol.toLowerCase().includes(searchQuery);
    const matchesFilter = (filterType === 'All') || (a.type === filterType);
    return matchesSearch && matchesFilter;
  });

  filtered.sort((a, b) => {
    const aStar = starredSymbols.includes(a.symbol);
    const bStar = starredSymbols.includes(b.symbol);
    if (aStar && !bStar) return -1;
    if (!aStar && bStar) return 1;
    return a.name.localeCompare(b.name);
  });

  assetsTableBodyEl.innerHTML = '';

  for (let asset of filtered) {
    const tr = document.createElement('tr');

    const starTd = document.createElement('td');
    const starIcon = document.createElement('span');
    starIcon.textContent = '★';
    starIcon.classList.add('star'); // This class needs to be defined in main.css or here
    if (starredSymbols.includes(asset.symbol)) {
      starIcon.classList.add('filled'); // This class needs to be defined
    }
    starIcon.onclick = () => toggleStar_assets(asset.symbol);
    starTd.appendChild(starIcon);
    tr.appendChild(starTd);

    const nameTd = document.createElement('td');
    nameTd.textContent = asset.name;
    tr.appendChild(nameTd);

    const typeTd = document.createElement('td');
    typeTd.textContent = asset.type;
    tr.appendChild(typeTd);

    let priceEur = 0;
    if (asset.type === 'Crypto') {
      const usdPrice = getUsdPriceFromShortName_assets(asset.symbol);
      const eurRate = exchangeRates_assets['EUR'] || 1;
      priceEur = usdPrice * eurRate;
    } else if (asset.type === 'Fiat') {
      priceEur = (asset.symbol === 'EUR') ? 1 : 0; // Simplified
    } else { // Stocks
      priceEur = 0; // Placeholder
    }
    const priceTd = document.createElement('td');
    priceTd.textContent = '€' + formatNumber_assets(priceEur) + '/' + asset.symbol;
    tr.appendChild(priceTd);

    let userBalance = '0.00';
    const foundWallet = userWallets_assets.find(w => w.shortName.toUpperCase() === asset.symbol.toUpperCase());
    if (foundWallet && foundWallet.balance) {
      userBalance = foundWallet.balance;
    }
    const walletTd = document.createElement('td');
    walletTd.textContent = userBalance + ' ' + asset.symbol;
    tr.appendChild(walletTd);

    const actionTd = document.createElement('td');
    const actionDiv = document.createElement('div');
    actionDiv.classList.add('d-flex'); // Bootstrap-like class, ensure defined in main.css
    actionDiv.style.gap = '0.5rem';
    actionDiv.style.flexWrap = 'wrap';

    const depositBtn = document.createElement('button');
    depositBtn.textContent = 'Deposit';
    depositBtn.classList.add('btn', 'btn-primary', 'btn-sm'); // Use dashboard button styles
    depositBtn.onclick = () => window.navigateToPage('deposit'); // Use SPA navigation
    actionDiv.appendChild(depositBtn);

    const withdrawBtn = document.createElement('button');
    withdrawBtn.textContent = 'Withdraw';
    withdrawBtn.classList.add('btn', 'btn-secondary', 'btn-sm'); // Use dashboard button styles
    withdrawBtn.onclick = () => window.navigateToPage('withdraw'); // Use SPA navigation
    actionDiv.appendChild(withdrawBtn);

    actionTd.appendChild(actionDiv);
    tr.appendChild(actionTd);

    assetsTableBodyEl.appendChild(tr);
  }
}

function getStarredAssets_assets() {
  const name = 'starred=';
  const decoded = decodeURIComponent(document.cookie);
  const parts = decoded.split(';');
  for (let p of parts) {
    const c = p.trim();
    if (c.startsWith(name)) {
      return c.substring(name.length).split(',');
    }
  }
  return [];
}

function setStarredAssets_assets(arr) {
  const expires = new Date();
  expires.setFullYear(expires.getFullYear() + 1);
  document.cookie = 'starred=' + arr.join(',') + '; path=/; expires=' + expires.toUTCString();
}

function toggleStar_assets(symbol) {
  let starred = getStarredAssets_assets();
  if (starred.includes(symbol)) {
    starred = starred.filter(s => s !== symbol);
  } else {
    starred.push(symbol);
    alert('Added to watchlist');
  }
  setStarredAssets_assets(starred);
  renderTable_assets();
}

function getUsdPriceFromShortName_assets(shortName) {
  const key = guessCoinGeckoKey_assets(shortName);
  if (!coinPricesUSD_assets[key] || !coinPricesUSD_assets[key].usd) {
    return 1; // Fallback for unknown as stable $1
  }
  return coinPricesUSD_assets[key].usd;
}

function guessCoinGeckoKey_assets(shortName) {
  const upper = shortName.toUpperCase();
  if (coinGeckoMap_assets[upper]) return coinGeckoMap_assets[upper];
  return 'usd-coin'; // Fallback as stable
}

function formatNumber_assets(num) {
  if (!num || isNaN(num)) return '0.00';
  return parseFloat(num).toLocaleString('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 6
  });
}

// Star styling for assets page (if not globally available)
if (!document.getElementById('assets-star-style')) {
    const style = document.createElement('style');
    style.id = 'assets-star-style';
    style.textContent = '.star { cursor: pointer; font-size: 18px; color: var(--text-secondary); transition: all 0.2s; } .star.filled { color: #ffd700; } .star:hover { transform: scale(1.2); } .btn-sm { padding: 0.25rem 0.5rem; font-size: 0.875rem; }';
    document.head.appendChild(style);
}

scripts/dashboard.js
/**
 * Dashboard Main JavaScript
 * Handles SPA navigation, modals, and all dashboard functionality
 */

// Global state
let currentUser = null;
let currentPage = 'dashboard';
let isLoading = false;

// DOM elements
const loadingOverlay = document.getElementById('loadingOverlay');
const pageContent = document.getElementById('page-content');
const sidebar = document.getElementById('sidebar');
const mobileMenuToggle = document.getElementById('mobileMenuToggle');
const mobileClose = document.getElementById('mobileClose');
const notificationBtn = document.getElementById('notificationBtn');
const notificationPopup = document.getElementById('notificationPopup');
const profileBtn = document.getElementById('profileBtn');
const profileDropdown = document.getElementById('profileDropdown');
const modalOverlay = document.getElementById('modalOverlay');

// Modal elements
const profileModal = document.getElementById('profileModal');
const settingsModal = document.getElementById('settingsModal');
const connectWalletModal = document.getElementById('connectWalletModal');
const referralsModal = document.getElementById('referralsModal');

/**
 * Initialize the dashboard
 */
document.addEventListener('DOMContentLoaded', async () => {
  try {
    showLoading();
    
    // Ensure all modals are hidden initially
    initializeModals();
    
    // Check authentication
    await checkAuthentication();
    
    // Setup event listeners
    setupEventListeners();
    
    // Load initial page based on hash or default to dashboard
    const initialPage = window.location.hash.replace('#', '') || 'dashboard';
    await loadPage(initialPage);
    
    // Load user data
    await loadUserData();
    
    hideLoading();
  } catch (error) {
    console.error('Dashboard initialization error:', error);
    handleAuthError();
  }
});

/**
 * Initialize modals to ensure they're hidden
 */
function initializeModals() {
  // Ensure all side modals are hidden initially
  const allModals = document.querySelectorAll('.side-modal');
  allModals.forEach(modal => {
    modal.classList.remove('active');
  });
  
  // Ensure modal overlay is hidden
  if (modalOverlay) {
    modalOverlay.classList.remove('active');
  }
  
  // Ensure dropdowns are hidden
  if (notificationPopup) {
    notificationPopup.classList.remove('active');
  }
  
  if (profileDropdown) {
    profileDropdown.classList.remove('active');
  }
}

/**
 * Check if user is authenticated
 */
async function checkAuthentication() {
  try {
    const response = await fetch('/api/auth/me', { 
      credentials: 'include' 
    });
    
    if (!response.ok) {
      throw new Error('Not authenticated');
    }
    
    const data = await response.json();
    currentUser = data.user;
    
    // Update UI with user info
    updateUserInfo();
    
  } catch (error) {
    console.error('Authentication check failed:', error);
    throw error;
  }
}

/**
 * Load user data and update UI
 */
async function loadUserData() {
  if (!currentUser) return;
  
  try {
    // Update profile modal with user data
    document.getElementById('profileName').textContent = `${currentUser.firstName} ${currentUser.lastName}`;
    document.getElementById('profileEmail').textContent = currentUser.email;
    document.getElementById('firstName').value = currentUser.firstName || '';
    document.getElementById('lastName').value = currentUser.lastName || '';
    document.getElementById('email').value = currentUser.email || '';
    document.getElementById('phone').value = currentUser.phone || '';
    document.getElementById('country').value = currentUser.country || '';
    document.getElementById('accountCurrency').value = currentUser.accountCurrency || '';
    
    // Load notifications
    await loadNotifications();
    
  } catch (error) {
    console.error('Error loading user data:', error);
  }
}

/**
 * Update user info in UI
 */
function updateUserInfo() {
  if (!currentUser) return;
  
  // Update any user-specific UI elements
  const userElements = document.querySelectorAll('[data-user-info]');
  userElements.forEach(element => {
    const field = element.dataset.userInfo;
    if (currentUser[field]) {
      element.textContent = currentUser[field];
    }
  });
}

/**
 * Setup all event listeners
 */
function setupEventListeners() {
  // Mobile menu toggle
  mobileMenuToggle?.addEventListener('click', toggleMobileMenu);
  mobileClose?.addEventListener('click', closeMobileMenu);
  
  // Navigation
  setupNavigation();
  
  // Header actions
  notificationBtn?.addEventListener('click', toggleNotifications);
  profileBtn?.addEventListener('click', toggleProfileDropdown);
  
  // Profile dropdown actions
  document.getElementById('profileSettingsBtn')?.addEventListener('click', openSettingsModal);
  document.getElementById('profileDetailsBtn')?.addEventListener('click', openProfileModal);
  document.getElementById('logoutBtn')?.addEventListener('click', handleLogout);
  
  // Modal close buttons
  setupModalCloseButtons();
  
  // Modal overlay click to close
  modalOverlay?.addEventListener('click', closeAllModals);
  
  // Prevent modal content clicks from closing modal
  document.querySelectorAll('.side-modal').forEach(modal => {
    modal.addEventListener('click', (e) => e.stopPropagation());
  });
  
  // Close dropdowns when clicking outside
  document.addEventListener('click', handleOutsideClick);
  
  // Handle browser back/forward
  window.addEventListener('popstate', handlePopState);
  
  // Referral link copy
  document.getElementById('copyReferralLink')?.addEventListener('click', copyReferralLink);
}

/**
 * Setup navigation event listeners
 */
function setupNavigation() {
  const navItems = document.querySelectorAll('.nav-item');
  
  navItems.forEach(item => {
    item.addEventListener('click', async (e) => {
      e.preventDefault();
      
      const page = item.dataset.page;
      if (!page) return;
      
      // Special handling for modal-based pages
      if (page === 'connect') {
        openConnectWalletModal();
        return;
      }
      
      if (page === 'referrals') {
        openReferralsModal();
        return;
      }
      
      // Regular page navigation
      await navigateToPage(page);
      
      // Close mobile menu if open
      if (window.innerWidth <= 768) {
        closeMobileMenu();
      }
    });
  });
}

/**
 * Setup modal close button event listeners
 */
function setupModalCloseButtons() {
  const closeButtons = [
    'closeNotifications',
    'closeProfileModal',
    'closeSettingsModal', 
    'closeConnectModal',
    'closeReferralsModal'
  ];
  
  closeButtons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.addEventListener('click', closeAllModals);
    }
  });
}

/**
 * Navigate to a specific page
 */
async function navigateToPage(page) {
  if (isLoading) return;
  
  try {
    showLoading();
    
    // Update URL without reloading
    window.history.pushState({ page }, '', `#${page}`);
    
    // Load the page
    await loadPage(page);
    
    // Update active nav item
    updateActiveNavItem(page);
    
    hideLoading();
    
  } catch (error) {
    console.error(`Error navigating to ${page}:`, error);
    hideLoading();
  }
}

/**
 * Load page content
 */
async function loadPage(page) {
  currentPage = page;
  
  try {
    let content = '';
    
    switch (page) {
      case 'dashboard':
        content = await loadDashboardPage();
        break;
      case 'deposit':
        content = await loadDepositPage();
        break;
      case 'withdraw':
        content = await loadWithdrawPage();
        break;
      case 'assets':
        content = await loadAssetsPage();
        break;
      case 'markets':
        content = await loadMarketsPage();
        break;
      case 'trade':
        content = await loadTradePage();
        break;
      case 'convert':
        content = await loadConvertPage();
        break;
      case 'subscribe':
        content = await loadSubscribePage();
        break;
      case 'signals':
        content = await loadSignalsPage();
        break;
      case 'stake':
        content = await loadStakePage();
        break;
      case 'experts':
        content = await loadExpertsPage();
        break;
      default:
        content = await loadDashboardPage();
    }
    
    // Insert content and initialize page-specific functionality
    pageContent.innerHTML = content;
    
    // Add fade-in animation to content
    pageContent.style.opacity = '0';
    setTimeout(() => {
      pageContent.style.opacity = '1';
      pageContent.style.transition = 'opacity 0.3s ease';
    }, 50);
    
    await initializePageFunctionality(page);
    
  } catch (error) {
    console.error(`Error loading ${page} page:`, error);
    pageContent.innerHTML = `
      <div class="card">
        <div class="card-body text-center">
          <i class="material-icons" style="font-size: 3rem; color: var(--error-color); margin-bottom: 1rem;">error_outline</i>
          <h3>Failed to load page content</h3>
          <p class="text-muted">Please try again or contact support if the problem persists.</p>
          <button class="btn btn-primary" onclick="location.reload()">
            <i class="material-icons">refresh</i>
            Retry
          </button>
        </div>
      </div>
    `;
  }
}

/**
 * Load Dashboard Page
 */
async function loadDashboardPage() {
  return `
    <div class="dashboard-header fade-in">
      <h1 class="dashboard-title">Welcome back, ${currentUser?.firstName || 'User'}!</h1>
      <p class="dashboard-subtitle">Here's what's happening with your portfolio today.</p>
    </div>
    
    <div class="stats-grid fade-in">
      <div class="stat-card">
        <div class="stat-icon">
          <i class="material-icons">account_balance_wallet</i>
        </div>
        <div class="stat-value" id="totalBalance">$0.00</div>
        <div class="stat-label">Total Balance</div>
      </div>
      
      <div class="stat-card">
        <div class="stat-icon">
          <i class="material-icons">trending_up</i>
        </div>
        <div class="stat-value" id="todayChange">+$0.00</div>
        <div class="stat-label">Today's Change</div>
      </div>
      
      <div class="stat-card">
        <div class="stat-icon">
          <i class="material-icons">pie_chart</i>
        </div>
        <div class="stat-value" id="portfolioCount">0</div>
        <div class="stat-label">Assets</div>
      </div>
      
      <div class="stat-card">
        <div class="stat-icon">
          <i class="material-icons">history</i>
        </div>
        <div class="stat-value" id="recentTransactions">0</div>
        <div class="stat-label">Recent Transactions</div>
      </div>
    </div>
    
    <div class="card fade-in">
      <div class="card-header">
        <h2 class="card-title">Quick Actions</h2>
      </div>
      <div class="card-body">
        <div class="d-flex" style="gap: 1rem; flex-wrap: wrap;">
          <button class="btn btn-primary" onclick="navigateToPage('deposit')">
            <i class="material-icons">add</i>
            Deposit
          </button>
          <button class="btn btn-secondary" onclick="navigateToPage('withdraw')">
            <i class="material-icons">remove</i>
            Withdraw
          </button>
          <button class="btn btn-secondary" onclick="navigateToPage('trade')">
            <i class="material-icons">swap_horiz</i>
            Trade
          </button>
          <button class="btn btn-secondary" onclick="navigateToPage('convert')">
            <i class="material-icons">currency_exchange</i>
            Convert
          </button>
        </div>
      </div>
    </div>
    
    <div class="card fade-in">
      <div class="card-header">
        <h2 class="card-title">Recent Activity</h2>
      </div>
      <div class="card-body">
        <div id="recentActivity" class="text-muted text-center">
          Loading recent activity...
        </div>
      </div>
    </div>
  `;
}

/**
 * Load Deposit Page
 */
async function loadDepositPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Deposit Funds</h2>
        <button class="btn btn-primary" id="openDepositBtn">
          <i class="material-icons">add</i>
          Make a Deposit
        </button>
      </div>
      <div class="card-body">
        <div class="form-container" style="max-width: 100%; margin: 0;">
          <div class="form-group">
            <input type="text" id="searchInput" class="form-control" placeholder="Search by reference/method/type..." />
          </div>
          <div class="form-group">
            <select id="statusFilter" class="form-control">
              <option value="">All Statuses</option>
              <option value="pending_user_confirmation">Pending User Confirmation</option>
              <option value="pending_approval">Pending Admin Approval</option>
              <option value="confirmed">Confirmed (Approved)</option>
              <option value="rejected_by_admin">Rejected by Admin</option>
              <option value="canceled">Canceled (System)</option>
            </select>
          </div>
        </div>

        <div class="table-container">
          <table class="table" id="depositTable">
            <thead>
              <tr>
                <th>ID</th>
                <th>Date</th>
                <th>Reference</th>
                <th>Method</th>
                <th>Type</th>
                <th>Amount</th>
                <th id="tableTotalHeader">Total (Local)</th>
                <th>User Status</th>
                <th>Admin Status</th>
                <th>Approved Amount</th>
                <th>Admin Remarks</th>
              </tr>
            </thead>
            <tbody>
              <!-- Populated via JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Modal Overlay for Deposit Page -->
    <div class="modal-overlay" id="depositModalOverlay" style="display: none;">
      <div class="side-modal right-modal" id="depositModal">
        <div class="modal-header">
          <h2>Create a Deposit</h2>
          <button class="close-modal" id="modalCloseBtn">
            <i class="material-icons">close</i>
          </button>
        </div>
        <div class="modal-content">
          <form id="depositForm">
            <div class="form-group">
              <label>Type</label>
              <select id="depositType" name="type" class="form-control">
                <option value="crypto" selected>Crypto</option>
              </select>
            </div>

            <div class="form-group">
              <label>Method (Select a Coin)</label>
              <select id="depositMethod" name="method" class="form-control">
                <!-- Populated by user wallets -->
              </select>
            </div>

            <div class="form-group">
              <label>Wallet Address</label>
              <div class="d-flex" style="gap: 0.5rem;">
                <input type="text" id="depositAddress" class="form-control" readonly />
                <button type="button" class="btn btn-secondary" id="copyAddressBtn">
                  <i class="material-icons">content_copy</i>
                </button>
              </div>
            </div>

            <div class="form-group">
              <label>Amount (Crypto)</label>
              <input type="number" id="depositAmount" class="form-control" min="0" step="any" required />
            </div>

            <div class="form-group">
              <label>Equivalent in <span id="localCurrencyLabel">USD</span></label>
              <input type="text" id="localCurrencyEquivalent" class="form-control" readonly />
            </div>

            <button type="submit" class="btn btn-primary w-100" id="confirmDepositBtn">
              <i class="material-icons">add</i>
              Deposit
            </button>
          </form>

          <!-- Confirmation section after form is submitted -->
          <div class="confirmation-section" id="confirmationSection" style="display: none;">
            <div class="text-center">
              <i class="material-icons" style="font-size: 3rem; color: var(--success-color); margin-bottom: 1rem;">check_circle</i>
              <h3>Deposit Created Successfully!</h3>
            </div>
            <div class="mt-3">
              <p><strong>Reference:</strong> <span id="confirmRef"></span></p>
              <p><strong>Amount (Crypto):</strong> <span id="confirmAmountCrypto"></span></p>
              <p><strong>Local Currency:</strong> <span id="confirmAmountLocal"></span></p>
              <p><strong>Address:</strong> <span id="confirmAddress"></span> 
                <button class="btn btn-secondary btn-sm" id="copyConfirmAddressBtn">
                  <i class="material-icons">content_copy</i>
                </button>
              </p>
              <p>User Status: <strong>Pending User Confirmation</strong></p>
              <p>Admin Status: <strong>Pending Approval</strong></p>
              <div class="mt-3 p-3 bg-primary rounded">
                <p class="mb-0"><strong>Next Steps:</strong></p>
                <p class="mb-0">Send your crypto to the wallet address above and wait for confirmation.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

/**
 * Load Withdraw Page
 */
async function loadWithdrawPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Withdraw Funds</h2>
        <button class="btn btn-primary" id="openWithdrawBtn">
          <i class="material-icons">remove</i>
          Make a Withdrawal
        </button>
      </div>
      <div class="card-body">
        <div class="form-container" style="max-width: 100%; margin: 0;">
          <div class="form-group">
            <input type="text" id="searchInput" class="form-control" placeholder="Search by reference/method/type..." />
          </div>
          <div class="form-group">
            <select id="statusFilter" class="form-control">
              <option value="">All Statuses</option>
              <option value="pending">Pending</option>
              <option value="canceled">Canceled</option>
              <option value="confirmed">Confirmed</option>
            </select>
          </div>
        </div>

        <div class="table-container">
          <table class="table" id="withdrawTable">
            <thead>
              <tr>
                <th>ID</th>
                <th>Date</th>
                <th>Reference</th>
                <th>Method</th>
                <th>Type</th>
                <th>Amount</th>
                <th id="tableTotalHeader">Total (Local)</th>
                <th>Status</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody>
              <!-- Populated via JS -->
            </tbody>
          </table>
        </div>

        <div class="text-center mt-4" id="noWithdrawalsMsg" style="display: none;">
          <i class="material-icons" style="font-size: 3rem; color: var(--text-secondary); margin-bottom: 1rem;">receipt</i>
          <p class="text-muted">You have not made any withdrawals yet.</p>
        </div>
      </div>
    </div>

    <!-- Modal Overlay for Withdraw Page -->
    <div class="modal-overlay" id="withdrawModalOverlay" style="display: none;">
      <div class="side-modal right-modal" id="withdrawModal">
        <div class="modal-header">
          <h2>Create a Withdrawal</h2>
          <button class="close-modal" id="modalCloseBtn">
            <i class="material-icons">close</i>
          </button>
        </div>
        <div class="modal-content">
          <form id="withdrawForm">
            <div class="form-group">
              <label>Type</label>
              <select id="withdrawType" name="type" class="form-control">
                <option value="crypto" selected>Crypto</option>
                <option value="bank">Bank Transfer</option>
              </select>
            </div>

            <!-- CRYPTO FIELDS -->
            <div id="cryptoFields">
              <div class="form-group">
                <label>Coin</label>
                <select id="cryptoCoinSelect" class="form-control"></select>
              </div>

              <div class="form-group">
                <label>Destination Wallet Address</label>
                <input type="text" id="cryptoDestinationAddress" class="form-control" placeholder="Enter external wallet address" />
              </div>

              <div class="form-group">
                <label>Amount (Crypto)</label>
                <input type="number" id="cryptoAmount" class="form-control" min="0" step="any" />
              </div>

              <div class="form-group">
                <label>Equivalent in <span id="localCurrencyLabelCrypto">USD</span></label>
                <input type="text" id="cryptoLocalEquivalent" class="form-control" readonly />
              </div>
            </div>

            <!-- BANK TRANSFER FIELDS -->
            <div id="bankFields" style="display: none;">
              <div class="form-group">
                <label>Amount (<span id="localCurrencyLabelBank">USD</span>)</label>
                <input type="number" id="bankAmount" class="form-control" min="0" step="any" />
              </div>

              <div class="form-group">
                <label>Bank Details</label>
                <textarea id="bankDetails" rows="3" class="form-control" placeholder="Account name, number, routing info, etc."></textarea>
              </div>
            </div>

            <button type="submit" class="btn btn-primary w-100" id="confirmWithdrawBtn">
              <i class="material-icons">remove</i>
              Withdraw
            </button>
          </form>

          <!-- Confirmation section after form is submitted -->
          <div class="confirmation-section" id="confirmationSection" style="display: none;">
            <div class="text-center">
              <i class="material-icons" style="font-size: 3rem; color: var(--success-color); margin-bottom: 1rem;">check_circle</i>
              <h3>Withdrawal Created Successfully!</h3>
            </div>
            <div class="mt-3">
              <p><strong>Reference:</strong> <span id="confirmRef"></span></p>
              <p><strong>Amount:</strong> <span id="confirmAmount"></span></p>
              <p><strong>Local Currency:</strong> <span id="confirmAmountLocal"></span></p>
              <p><strong>Method:</strong> <span id="confirmMethod"></span></p>
              <p>Status: <strong>Pending</strong></p>
              <div class="mt-3 p-3 bg-primary rounded">
                <p class="mb-0"><strong>Processing Time:</strong></p>
                <p class="mb-0">Your withdrawal will be processed within 24-48 hours.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

/**
 * Load Assets Page
 */
async function loadAssetsPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Assets</h2>
        <div class="balance" id="totalBalanceDisplay">Total Balance: 0.00</div>
      </div>
      <div class="card-body">
        <div class="form-container" style="max-width: 100%; margin: 0;">
          <div class="form-group">
            <input type="text" id="searchBar" class="form-control" placeholder="Search assets..." />
          </div>
          <div class="form-group">
            <select id="filterSelect" class="form-control">
              <option value="All">All Types</option>
              <option value="Crypto">Crypto</option>
              <option value="Fiat">Fiat</option>
              <option value="Stocks">Stocks</option>
            </select>
          </div>
        </div>

        <div class="table-container">
          <table class="table">
            <thead>
              <tr>
                <th>★</th>
                <th>Asset</th>
                <th>Type</th>
                <th>Current Price (EUR)</th>
                <th>In Your Wallet</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="assetsTableBody">
              <!-- Populated by JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Recent Activity</h2>
      </div>
      <div class="card-body">
        <div id="notificationList">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>
  `;
}

/**
 * Load Markets Page
 */
async function loadMarketsPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Markets</h2>
      </div>
      <div class="card-body">
        <div class="form-container" style="max-width: 100%; margin: 0;">
          <div class="form-group">
            <input type="text" id="searchBar" class="form-control" placeholder="Search assets..." />
          </div>
          <div class="form-group">
            <select id="filterSelect" class="form-control">
              <option value="All">All Types</option>
              <option value="Crypto">Crypto</option>
              <option value="Fiat">Fiat</option>
              <option value="Stocks">Stocks</option>
            </select>
          </div>
        </div>

        <div class="table-container">
          <table class="table">
            <thead>
              <tr>
                <th>★</th>
                <th>Asset</th>
                <th>Type</th>
                <th>Current Price (EUR)</th>
                <th>In Your Wallet</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="assetsTableBody">
              <!-- Populated by JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  `;
}

/**
 * Load Trade Page
 */
async function loadTradePage() {
  // This HTML is taken from your `trade.html` demo file
  // Note: jQuery and Select2 script tags are included here for self-containment.
  // Ideally, they should be in `dashboard/index.html` if used by multiple pages.
  return `
    <!-- Select2 CSS for custom dropdowns with images -->
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <!-- Google Material Icons for fiat icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
      /* Embedded styles from trade.html, adapted for dashboard variables */
      /* Global Styles */
      #page-content * { /* Scoping to page-content might be too broad, be careful */
        box-sizing: border-box;
        /* margin: 0; Let dashboard handle global margin/padding */
        /* padding: 0; */
      }
      #page-content .trade-container { /* Added a wrapper for trade page specific content */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--secondary-bg); /* Use dashboard variable */
        color: var(--text-color); /* Use dashboard variable */
        line-height: 1.6;
        padding: 20px;
        border-radius: 8px;
      }
      #page-content a {
        color: #1e90ff; /* Or var(--accent-color) */
      }
      /* Tabs */
      #page-content .trade-tabs {
        display: flex;
        border-bottom: 1px solid var(--border-color); /* Use dashboard variable */
        margin-bottom: 20px;
      }
      #page-content .trade-tabs button {
        padding: 10px 20px;
        cursor: pointer;
        background-color: var(--hover-bg); /* Use dashboard variable */
        border: none;
        border-right: 1px solid var(--border-color); /* Use dashboard variable */
        font-size: 16px;
        outline: none;
        color: var(--text-color); /* Use dashboard variable */
        transition: background-color 0.3s ease;
      }
      #page-content .trade-tabs button:last-child {
        border-right: none;
      }
      #page-content .trade-tabs button.active {
        background-color: var(--secondary-bg); /* Use dashboard variable */
        border-bottom: 3px solid var(--accent-color); /* Use dashboard variable */
        font-weight: bold;
      }
      #page-content .tab-content {
        display: none;
      }
      #page-content .tab-content.active {
        display: block;
      }
      /* Form styles */
      #page-content .trade-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-width: 600px;
        margin-bottom: 30px;
      }
      #page-content .trade-form label {
        font-weight: bold;
        margin-top: 8px;
        color: var(--text-secondary); /* Use dashboard variable */
      }
      #page-content .trade-form select,
      #page-content .trade-form input {
        padding: 10px;
        font-size: 14px;
        border-radius: 4px;
        border: 1px solid var(--border-color); /* Use dashboard variable */
        background-color: var(--primary-bg); /* Use dashboard variable */
        color: var(--text-color); /* Use dashboard variable */
        width: 100%;
      }
      #page-content .trade-form input[readonly] {
        background-color: var(--hover-bg); /* Use dashboard variable */
      }
      #page-content .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      #page-content .row > div {
        flex: 1;
        min-width: 120px;
      }
      #page-content .error {
        color: var(--error-color); /* Use dashboard variable */
        font-weight: bold;
      }
      #page-content .success {
        color: var(--success-color); /* Use dashboard variable */
        font-weight: bold;
      }
      #page-content .trade-form button { /* This is for the main buy/sell/convert button */
        padding: 12px;
        font-size: 16px;
        background-color: var(--accent-color); /* Use dashboard variable */
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
        transition: background-color 0.3s ease;
      }
      #page-content .trade-form button:disabled {
        background-color: #555; /* Needs a var(--disabled-bg) */
        cursor: not-allowed;
      }
      #page-content .trade-form button:hover:enabled {
        background-color: #187bcd; /* Needs a var(--accent-hover-color) */
      }
      #page-content .loading-spinner {
        display: inline-block;
        width: 18px;
        height: 18px;
        border: 3px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s linear infinite;
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      /* Asset icons */
      #page-content .asset-select-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #page-content .asset-select-container select {
        flex: 1;
      }
      #page-content .asset-icon {
        width: 24px;
        height: 24px;
        vertical-align: middle;
        border-radius: 50%;
        object-fit: cover;
        border: 1px solid var(--border-color); /* Use dashboard variable */
      }
      /* Leverage slider */
      #page-content .leverage-slider-container {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      #page-content .leverage-slider {
        flex: 1;
        -webkit-appearance: none;
        height: 6px;
        border-radius: 3px;
        background: var(--border-color); /* Use dashboard variable */
        outline: none;
      }
      #page-content .leverage-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent-color); /* Use dashboard variable */
        cursor: pointer;
      }
      #page-content .hint {
        font-size: 0.9rem;
        color: var(--text-secondary); /* Use dashboard variable */
      }
      /* Responsive */
      @media (max-width: 768px) {
        #page-content .trade-container {
          margin: 10px;
          padding: 15px;
        }
        #page-content .trade-tabs button {
          padding: 8px 12px;
          font-size: 14px;
        }
        #page-content .trade-form {
          max-width: 100%;
        }
        #page-content .row {
          flex-direction: column;
        }
      }
      /* Custom Select2 Overrides */
      .select2-container--default .select2-selection--single {
        background-color: var(--primary-bg) !important; /* Use dashboard variable */
        border: 1px solid var(--border-color) !important; /* Use dashboard variable */
        border-radius: 4px !important;
        padding: 5px 10px !important;
        color: var(--text-color) !important; /* Use dashboard variable */
        height: auto !important; /* Default Select2 is 38px, make it auto to match inputs */
      }
      .select2-container--default .select2-selection--single .select2-selection__rendered {
        color: var(--text-color) !important; /* Use dashboard variable */
        line-height: 1.6 !important; /* Match form input line-height */
      }
      .select2-container--default .select2-selection--single .select2-selection__arrow {
        height: 38px !important; /* Adjust to match padded height */
        right: 5px !important;
      }
      .select2-container--default .select2-selection--single .select2-selection__arrow b {
         border-color: var(--text-secondary) transparent transparent transparent !important; /* Arrow color */
      }
      .select2-dropdown {
        background-color: var(--secondary-bg) !important; /* Dropdown background */
        border: 1px solid var(--border-color) !important;
      }
      .select2-container .select2-results__option {
        background-color: var(--secondary-bg) !important; /* Use dashboard variable */
        color: var(--text-color) !important; /* Use dashboard variable */
      }
      .select2-container .select2-results__option--highlighted {
        background-color: var(--hover-bg) !important; /* Use dashboard variable */
      }
       .select2-search--dropdown .select2-search__field {
        background-color: var(--primary-bg) !important;
        color: var(--text-color) !important;
        border: 1px solid var(--border-color) !important;
      }
    </style>

    <div class="card">
      <div class="card-header">
          <h2 class="card-title">Trade Platform</h2>
      </div>
      <div class="card-body trade-container"> <!-- Added trade-container for scoping -->
        <!-- TABS: BUY / SELL / CONVERT -->
        <div class="trade-tabs">
          <button id="tabBuy" class="active">Buy</button>
          <button id="tabSell">Sell</button>
          <button id="tabConvert">Convert</button>
        </div>

        <!-- BUY TAB CONTENT -->
        <div id="buyTabContent" class="tab-content active">
          <form class="trade-form" id="buyForm">
            <label for="buyMarket">Market Type:</label>
            <select id="buyMarket">
              <option value="Crypto">Crypto</option>
              <option value="Stocks">Stocks</option>
              <option value="Forex">Forex</option>
            </select>

            <div id="buySingleSymbolSection">
              <label for="buySymbol">Asset:</label>
              <div class="asset-select-container">
                <select id="buySymbol"></select>
                <img src="https://via.placeholder.com/24?text=?" alt="Asset Icon" id="buySymbolIcon" class="asset-icon" />
              </div>
              <div class="hint" id="buyAssetPrice"></div>
            </div>
            <div id="buyForexSection" style="display: none;">
              <label for="buyForexBase">Base Currency:</label>
              <div class="asset-select-container">
                <select id="buyForexBase"></select>
                <span id="buyForexBaseIcon" class="asset-icon"></span>
              </div>
              <label for="buyForexQuote">Quote Currency:</label>
              <div class="asset-select-container">
                <select id="buyForexQuote"></select>
                <span id="buyForexQuoteIcon" class="asset-icon"></span>
              </div>
            </div>

            <div class="hint" id="buyBalanceInfo"></div>

            <div class="row">
              <div>
                <label for="buyAmount">Amount to BUY:</label>
                <input type="number" step="any" id="buyAmount" placeholder="0.00" />
              </div>
              <div>
                <label>Est. Cost (<span id="buyCurrencyLabel"></span>):</label>
                <input type="text" id="buyCostDisplay" readonly />
              </div>
            </div>

            <label>Leverage:</label>
            <div class="leverage-slider-container">
              <input type="range" id="buyLeverageSlider" class="leverage-slider" min="1" max="100" value="1" />
              <span id="buyLeverageValue">1x</span>
            </div>

            <div class="row">
              <div>
                <label for="buyStopLoss">Stop Loss:</label>
                <input type="number" id="buyStopLoss" step="any" />
              </div>
              <div>
                <label for="buyTakeProfit">Take Profit:</label>
                <input type="number" id="buyTakeProfit" step="any" />
              </div>
            </div>

            <label for="buyDuration">Trade Duration:</label>
            <select id="buyDuration">
              <option value="Short (Minutes)">Short (Minutes)</option>
              <option value="Day (Hours)">Day (Hours)</option>
              <option value="Swing (Days)">Swing (Days)</option>
              <option value="Long (Weeks)">Long (Weeks)</option>
            </select>
            
            <label for="buyOrderType">Order Type:</label>
            <select id="buyOrderType">
              <option value="market" selected>Market Order</option>
              <option value="limit">Limit Order</option>
            </select>
            <div id="buyLimitPriceSection" style="display: none;">
              <label for="buyLimitPrice">Limit Price:</label>
              <input type="number" step="any" id="buyLimitPrice" placeholder="0.00" />
            </div>

            <div class="error" id="buyError" style="display: none;"></div>
            <div class="success" id="buySuccess" style="display: none;"></div>

            <button type="submit" id="buyButton" disabled>Buy</button>
          </form>
        </div>

        <!-- SELL TAB CONTENT -->
        <div id="sellTabContent" class="tab-content">
          <form class="trade-form" id="sellForm">
            <label for="sellMarket">Market Type:</label>
            <select id="sellMarket">
              <option value="Crypto">Crypto</option>
              <option value="Stocks">Stocks</option>
              <option value="Forex">Forex</option>
            </select>

            <div id="sellSingleSymbolSection">
              <label for="sellSymbol">Asset:</label>
              <div class="asset-select-container">
                <select id="sellSymbol"></select>
                <img src="https://via.placeholder.com/24?text=?" alt="Asset Icon" id="sellSymbolIcon" class="asset-icon" />
              </div>
              <div class="hint" id="sellAssetPrice"></div>
            </div>
            <div id="sellForexSection" style="display: none;">
              <label for="sellForexBase">Base Currency:</label>
              <div class="asset-select-container">
                <select id="sellForexBase"></select>
                <span id="sellForexBaseIcon" class="asset-icon"></span>
              </div>
              <label for="sellForexQuote">Quote Currency:</label>
              <div class="asset-select-container">
                <select id="sellForexQuote"></select>
                <span id="sellForexQuoteIcon" class="asset-icon"></span>
              </div>
            </div>

            <div class="hint" id="sellBalanceInfo"></div>

            <div class="row">
              <div>
                <label for="sellAmount">Amount to SELL:</label>
                <input type="number" step="any" id="sellAmount" placeholder="0.00" />
              </div>
              <div>
                <label>Est. Value (<span id="sellCurrencyLabel"></span>):</label>
                <input type="text" id="sellValueDisplay" readonly />
              </div>
            </div>

            <label>Leverage:</label>
            <div class="leverage-slider-container">
              <input type="range" id="sellLeverageSlider" class="leverage-slider" min="1" max="100" value="1" />
              <span id="sellLeverageValue">1x</span>
            </div>

            <div class="row">
              <div>
                <label for="sellStopLoss">Stop Loss:</label>
                <input type="number" id="sellStopLoss" step="any" />
              </div>
              <div>
                <label for="sellTakeProfit">Take Profit:</label>
                <input type="number" id="sellTakeProfit" step="any" />
              </div>
            </div>

            <label for="sellDuration">Trade Duration:</label>
            <select id="sellDuration">
              <option value="Short (Minutes)">Short (Minutes)</option>
              <option value="Day (Hours)">Day (Hours)</option>
              <option value="Swing (Days)">Swing (Days)</option>
              <option value="Long (Weeks)">Long (Weeks)</option>
            </select>
            
            <label for="sellOrderType">Order Type:</label>
            <select id="sellOrderType">
              <option value="market" selected>Market Order</option>
              <option value="limit">Limit Order</option>
            </select>
            <div id="sellLimitPriceSection" style="display: none;">
              <label for="sellLimitPrice">Limit Price:</label>
              <input type="number" step="any" id="sellLimitPrice" placeholder="0.00" />
            </div>

            <div class="error" id="sellError" style="display: none;"></div>
            <div class="success" id="sellSuccess" style="display: none;"></div>

            <button type="submit" id="sellButton" disabled>Sell</button>
          </form>
        </div>

        <!-- CONVERT TAB CONTENT -->
        <div id="convertTabContent" class="tab-content">
          <form class="trade-form" id="convertForm">
            <label for="convertFrom">From Asset:</label>
            <div class="asset-select-container">
              <select id="convertFrom"></select>
              <img src="https://via.placeholder.com/24?text=?" alt="From Asset Icon" id="convertFromIcon" class="asset-icon" />
            </div>

            <div class="hint" id="convertFromBalHint"></div>

            <label for="convertAmount">Amount:</label>
            <input type="number" step="any" id="convertAmount" placeholder="0.00" />

            <label for="convertTo">To Asset:</label>
            <div class="asset-select-container">
              <select id="convertTo"></select>
              <img src="https://via.placeholder.com/24?text=?" alt="To Asset Icon" id="convertToIcon" class="asset-icon" />
            </div>

            <div class="row">
              <div>
                <label>You Get:</label>
                <input type="text" id="convertResult" readonly />
              </div>
              <div>
                <label>1 <span id="convFromSymbol"></span> = </label>
                <input type="text" id="convertRateDisplay" readonly />
                <span id="convRateCurr"></span>
              </div>
            </div>

            <div class="error" id="convertError" style="display: none;"></div>
            <div class="success" id="convertSuccess" style="display: none;"></div>

            <button type="submit" id="convertButton" disabled>Convert</button>
          </form>
        </div>
      </div> <!-- .trade-container -->
    </div> <!-- .card -->

    <!-- jQuery and Select2 JS (placed here so they load before our inline script) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
  `;
}

async function loadConvertPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Convert Assets</h2>
      </div>
      <div class="card-body">
        <div class="form-container" style="max-width: 100%;">
          <div class="form-group">
            <label>From Asset</label>
            <select class="form-control" id="fromAsset">
              <option value="">Select asset to convert from</option>
              <option value="BTC">Bitcoin (BTC)</option>
              <option value="ETH">Ethereum (ETH)</option>
              <option value="USDT">Tether (USDT)</option>
              <option value="USD">US Dollar (USD)</option>
            </select>
          </div>
          
          <div class="form-group">
            <label>Amount</label>
            <input type="number" class="form-control" id="convertAmount" placeholder="Enter amount" min="0" step="any">
          </div>
          
          <div class="form-group">
            <label>To Asset</label>
            <select class="form-control" id="toAsset">
              <option value="">Select asset to convert to</option>
              <option value="BTC">Bitcoin (BTC)</option>
              <option value="ETH">Ethereum (ETH)</option>
              <option value="USDT">Tether (USDT)</option>
              <option value="USD">US Dollar (USD)</option>
            </select>
          </div>
          
          <div class="card" style="background: var(--primary-bg); border: 1px solid var(--border-color); margin: 1.5rem 0;">
            <div class="card-body">
              <div class="d-flex flex-between">
                <span>Exchange Rate:</span>
                <span id="exchangeRate">-</span>
              </div>
              <div class="d-flex flex-between">
                <span>You'll receive:</span>
                <strong id="receiveAmount">-</strong>
              </div>
              <div class="d-flex flex-between">
                <span>Network Fee:</span>
                <span id="networkFee">$0.00</span>
              </div>
            </div>
          </div>
          
          <button class="btn btn-primary w-100" id="convertBtn" disabled>
            <i class="material-icons">swap_horiz</i>
            Convert
          </button>
        </div>
      </div>
    </div>
  `;
}

async function loadSubscribePage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Subscription Plans</h2>
      </div>
      <div class="card-body">
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-icon">
              <i class="material-icons">stars</i>
            </div>
            <div class="stat-value">Free</div>
            <div class="stat-label">Basic Trading</div>
            <div style="margin-top: 1rem;">
              <button class="btn btn-secondary w-100">Current Plan</button>
            </div>
          </div>
          
          <div class="stat-card" style="border-color: var(--accent-color);">
            <div class="stat-icon">
              <i class="material-icons">diamond</i>
            </div>
            <div class="stat-value">$29</div>
            <div class="stat-label">Pro Trading</div>
            <div style="margin-top: 1rem;">
              <button class="btn btn-primary w-100">Upgrade</button>
            </div>
          </div>
          
          <div class="stat-card">
            <div class="stat-icon">
              <i class="material-icons">workspace_premium</i>
            </div>
            <div class="stat-value">$99</div>
            <div class="stat-label">Premium</div>
            <div style="margin-top: 1rem;">
              <button class="btn btn-primary w-100">Upgrade</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

async function loadSignalsPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Trading Signals</h2>
      </div>
      <div class="card-body">
        <div class="text-center">
          <i class="material-icons" style="font-size: 4rem; color: var(--accent-color); margin-bottom: 1rem;">wifi</i>
          <h3>Trading Signals</h3>
          <p class="text-muted">Get real-time trading signals from our AI-powered system</p>
          <p class="text-muted">Coming soon...</p>
          <div style="margin-top: 2rem;">
            <button class="btn btn-primary">
              <i class="material-icons">notifications</i>
              Get Notified When Available
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
}

async function loadStakePage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Staking</h2>
      </div>
      <div class="card-body">
        <div class="text-center">
          <i class="material-icons" style="font-size: 4rem; color: var(--accent-color); margin-bottom: 1rem;">local_offer</i>
          <h3>Stake Your Assets</h3>
          <p class="text-muted">Earn rewards by staking your crypto assets</p>
          <p class="text-muted">Coming soon...</p>
          <div style="margin-top: 2rem;">
            <button class="btn btn-primary">
              <i class="material-icons">notifications</i>
              Get Notified When Available
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
}

async function loadExpertsPage() {
  return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Copy Expert Traders</h2>
      </div>
      <div class="card-body">
        <div class="text-center">
          <i class="material-icons" style="font-size: 4rem; color: var(--accent-color); margin-bottom: 1rem;">content_copy</i>
          <h3>Copy Trading</h3>
          <p class="text-muted">Follow and copy trades from expert traders</p>
          <p class="text-muted">Coming soon...</p>
          <div style="margin-top: 2rem;">
            <button class="btn btn-primary">
              <i class="material-icons">notifications</i>
              Get Notified When Available
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
}

/**
 * Initialize page-specific functionality
 */
async function initializePageFunctionality(page) {
  // Make current user available globally for page scripts
  window.currentUser = currentUser;
  
  switch (page) {
    case 'dashboard':
      await initializeDashboard();
      break;
    case 'deposit':
      await loadScript('../scripts/deposit.js');
      break;
    case 'withdraw':
      await loadScript('../scripts/withdraw.js');
      break;
    case 'assets':
      await loadScript('../scripts/assets.js');
      break;
    case 'markets':
      await loadScript('../scripts/markets.js');
      break;
    case 'trade':
      await loadScript('../scripts/trade.js');
      break;
    case 'convert':
      initializeConvert(); // This is a simple one, can be inline
      break;
  }
}

/**
 * Load external script dynamically
 */
async function loadScript(src) {
  return new Promise((resolve, reject) => {
    // Check if script is already loaded
    const existingScript = document.querySelector(`script[src="${src}"]`);
    if (existingScript) {
      existingScript.remove(); // Remove old script to allow reloading
    }
    
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

/**
 * Initialize dashboard functionality
 */
async function initializeDashboard() {
  try {
    // Load dashboard data
    await loadDashboardData();
  } catch (error) {
    console.error('Error initializing dashboard:', error);
  }
}

/**
 * Load dashboard data
 */
async function loadDashboardData() {
  try {
    // Load user wallets and calculate total balance
    const walletsResponse = await fetch(`/api/user/${currentUser.id}/wallets`, { 
      credentials: 'include' 
    });
    
    if (walletsResponse.ok) {
      const wallets = await walletsResponse.json();
      updateDashboardStats(wallets);
    }
    
    // Load recent activity
    await loadRecentActivity();
    
  } catch (error) {
    console.error('Error loading dashboard data:', error);
  }
}

/**
 * Update dashboard statistics
 */
function updateDashboardStats(wallets) {
  // Calculate total balance (simplified)
  let totalBalance = 0;
  wallets.forEach(wallet => {
    const balance = parseFloat(wallet.balance) || 0;
    // For simplicity, treating all as USD equivalent
    totalBalance += balance;
  });
  
  if (document.getElementById('totalBalance')) {
    document.getElementById('totalBalance').textContent = `$${totalBalance.toFixed(2)}`;
  }
  if (document.getElementById('portfolioCount')) {
    document.getElementById('portfolioCount').textContent = wallets.length;
  }
  
  // Mock data for other stats
  if (document.getElementById('todayChange')) {
    document.getElementById('todayChange').textContent = '+$12.34';
  }
  if (document.getElementById('recentTransactions')) {
    document.getElementById('recentTransactions').textContent = '3';
  }
}

/**
 * Load recent activity
 */
async function loadRecentActivity() {
  try {
    // Try to load recent notifications as activity
    const notifResponse = await fetch(`/api/user/${currentUser.id}/notifications`, {
      credentials: 'include'
    });
    
    const recentActivity = document.getElementById('recentActivity');
    if (!recentActivity) return; // Element might not be on current page view

    if (notifResponse.ok) {
      const notifications = await notifResponse.json();
      
      if (notifications.length === 0) {
        recentActivity.innerHTML = '<p class="text-muted">No recent activity</p>';
      } else {
        const activityList = notifications.slice(0, 5).map(notif => 
          `<div class="mb-2 p-3 bg-primary rounded">${notif.message}</div>`
        ).join('');
        recentActivity.innerHTML = activityList;
      }
    }
  } catch (error) {
    console.error('Error loading recent activity:', error);
    const recentActivity = document.getElementById('recentActivity');
    if (recentActivity) {
      recentActivity.innerHTML = '<p class="text-muted">Unable to load recent activity</p>';
    }
  }
}

function initializeConvert() {
  const fromAsset = document.getElementById('fromAsset');
  const toAsset = document.getElementById('toAsset');
  const convertAmountInput = document.getElementById('convertAmount'); // Renamed to avoid conflict
  const convertBtn = document.getElementById('convertBtn');
  
  // Add event listeners for convert functionality
  [fromAsset, toAsset, convertAmountInput].forEach(el => {
    if (el) {
      el.addEventListener('change', updateConvertPreview);
      el.addEventListener('input', updateConvertPreview);
    }
  });
  
  if (convertBtn) {
    convertBtn.addEventListener('click', handleConvert);
  }
}

/**
 * Update convert preview
 */
function updateConvertPreview() {
  const fromAssetEl = document.getElementById('fromAsset');
  const toAssetEl = document.getElementById('toAsset');
  const amountInputEl = document.getElementById('convertAmount'); // Renamed to avoid conflict
  const convertBtnEl = document.getElementById('convertBtn');
  
  if (!fromAssetEl || !toAssetEl || !amountInputEl || !convertBtnEl) return;

  const fromAsset = fromAssetEl.value;
  const toAsset = toAssetEl.value;
  const amount = parseFloat(amountInputEl.value) || 0;
  
  if (fromAsset && toAsset && amount > 0 && fromAsset !== toAsset) {
    // Mock exchange rate calculation
    const mockRate = Math.random() * 100 + 1;
    const receiveAmount = amount * mockRate;
    
    if(document.getElementById('exchangeRate')) document.getElementById('exchangeRate').textContent = `1 ${fromAsset} = ${mockRate.toFixed(6)} ${toAsset}`;
    if(document.getElementById('receiveAmount')) document.getElementById('receiveAmount').textContent = `${receiveAmount.toFixed(6)} ${toAsset}`;
    if(document.getElementById('networkFee')) document.getElementById('networkFee').textContent = '$2.50';
    
    convertBtnEl.disabled = false;
  } else {
    if(document.getElementById('exchangeRate')) document.getElementById('exchangeRate').textContent = '-';
    if(document.getElementById('receiveAmount')) document.getElementById('receiveAmount').textContent = '-';
    convertBtnEl.disabled = true;
  }
}

/**
 * Handle convert action
 */
function handleConvert() {
  alert('Convert functionality coming soon!');
}

/**
 * Update active navigation item
 */
function updateActiveNavItem(page) {
  // Remove active class from all nav items
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.remove('active');
  });
  
  // Add active class to current page
  const activeItem = document.querySelector(`[data-page="${page}"]`);
  if (activeItem) {
    activeItem.classList.add('active');
  }
}

/**
 * Handle browser back/forward
 */
function handlePopState(event) {
  const page = event.state?.page || window.location.hash.replace('#', '') || 'dashboard';
  loadPage(page);
  updateActiveNavItem(page);
}

/**
 * Mobile menu functions
 */
function toggleMobileMenu() {
  sidebar.classList.toggle('active');
}

function closeMobileMenu() {
  sidebar.classList.remove('active');
}

/**
 * Notification functions
 */
function toggleNotifications(e) {
  e.stopPropagation();
  notificationPopup.classList.toggle('active');
  profileDropdown.classList.remove('active');
}

async function loadNotifications() {
  try {
    const response = await fetch(`/api/user/${currentUser.id}/notifications`, {
      credentials: 'include'
    });
    
    if (response.ok) {
      const notifications = await response.json();
      updateNotificationUI(notifications);
    }
  } catch (error) {
    console.error('Error loading notifications:', error);
  }
}

function updateNotificationUI(notifications) {
  const popupContent = notificationPopup.querySelector('.popup-content');
  
  if (notifications.length === 0) {
    popupContent.innerHTML = `
      <div class="notification-empty">
        <i class="material-icons">notifications_none</i>
        <p>No new notifications</p>
        <p>You'll see your notifications here</p>
      </div>
    `;
  } else {
    const notificationsList = notifications.slice(0, 5).map(notif => `
      <div class="notification-item" style="padding: 1rem; border-bottom: 1px solid var(--border-color);">
        <p>${notif.message}</p>
        <small class="text-muted">${new Date(notif.createdAt).toLocaleDateString()}</small>
      </div>
    `).join('');
    
    popupContent.innerHTML = notificationsList;
  }
}

/**
 * Profile dropdown functions
 */
function toggleProfileDropdown(e) {
  e.stopPropagation();
  profileDropdown.classList.toggle('active');
  notificationPopup.classList.remove('active');
}

/**
 * Modal functions
 */
function openProfileModal() {
  closeAllDropdowns();
  closeAllModals(); // Close any other modals first
  setTimeout(() => {
    modalOverlay.classList.add('active');
    profileModal.classList.add('active');
  }, 100);
}

function openSettingsModal() {
  closeAllDropdowns();
  closeAllModals(); // Close any other modals first
  setTimeout(() => {
    modalOverlay.classList.add('active');
    settingsModal.classList.add('active');
  }, 100);
}

function openConnectWalletModal() {
  closeMobileMenu();
  closeAllDropdowns();
  closeAllModals(); // Close any other modals first
  setTimeout(() => {
    modalOverlay.classList.add('active');
    connectWalletModal.classList.add('active');
  }, 100);
}

function openReferralsModal() {
  closeMobileMenu();
  closeAllDropdowns();
  closeAllModals(); // Close any other modals first
  setTimeout(() => {
    modalOverlay.classList.add('active');
    referralsModal.classList.add('active');
  }, 100);
}

function closeAllModals() {
  modalOverlay.classList.remove('active');
  document.querySelectorAll('.side-modal').forEach(modal => {
    modal.classList.remove('active');
  });
  
  // Also close any page-specific modals
  const pageModals = document.querySelectorAll('.modal-overlay'); // Select all, including page-specific ones
  pageModals.forEach(modal => {
    // Check if it's a page-specific modal (not the main one)
    if (modal.id !== 'modalOverlay' && modal.style.display === 'flex') {
      modal.style.display = 'none';
    }
  });
}

function closeAllDropdowns() {
  notificationPopup.classList.remove('active');
  profileDropdown.classList.remove('active');
}

/**
 * Handle clicks outside of dropdowns
 */
function handleOutsideClick(e) {
  // Close notification popup if clicking outside
  if (notificationPopup && !notificationBtn.contains(e.target) && !notificationPopup.contains(e.target)) {
    notificationPopup.classList.remove('active');
  }
  
  // Close profile dropdown if clicking outside  
  if (profileDropdown && !profileBtn.contains(e.target) && !profileDropdown.contains(e.target)) {
    profileDropdown.classList.remove('active');
  }
  
  // Close mobile sidebar if clicking outside on mobile
  if (window.innerWidth <= 768 && 
      sidebar && !sidebar.contains(e.target) && 
      mobileMenuToggle && !mobileMenuToggle.contains(e.target)) {
    closeMobileMenu();
  }
  
  // Close side modals if clicking on main overlay
  if (modalOverlay && e.target === modalOverlay) {
    closeAllModals();
  }
}

/**
 * Copy referral link
 */
function copyReferralLink() {
  const referralInput = document.getElementById('referralLinkInput');
  if (referralInput) {
    referralInput.select();
    document.execCommand('copy');
    
    // Show feedback
    const copyBtn = document.getElementById('copyReferralLink');
    const originalText = copyBtn.innerHTML;
    copyBtn.innerHTML = '<i class="material-icons">check</i>';
    copyBtn.style.background = 'var(--success-color)';
    
    setTimeout(() => {
      copyBtn.innerHTML = originalText;
      copyBtn.style.background = 'var(--accent-color)';
    }, 2000);
  }
}

/**
 * Handle logout
 */
async function handleLogout() {
  try {
    const response = await fetch('/api/auth/logout', {
      method: 'POST',
      credentials: 'include'
    });
    
    // Redirect to login regardless of response
    window.location.href = '/login/';
    
  } catch (error) {
    console.error('Logout error:', error);
    // Still redirect on error
    window.location.href = '/login/';
  }
}

/**
 * Handle authentication errors
 */
function handleAuthError() {
  window.location.href = '/login/';
}

/**
 * Loading functions
 */
function showLoading() {
  isLoading = true;
  loadingOverlay.style.display = 'flex';
}

function hideLoading() {
  isLoading = false;
  loadingOverlay.style.display = 'none';
}

/**
 * Utility function to make navigateToPage available globally
 */
window.navigateToPage = navigateToPage;

scripts/deposit.js
/**
 * Deposit Page Functionality
 * Handles all deposit-related operations
 */

// Deposit functionality
let depositCurrentUser = window.currentUser;
let userWallets = [];
let deposits = [];
let coinPrices = {};
let exchangeRates = {};
let userCurrency = depositCurrentUser?.accountCurrency || 'USD';

// Telegram info
const TELEGRAM_BOT_TOKEN = '7504988589:AAGRqHBTqeC7UH6AlX6TqAYn6u2wtTXkCcA'; 
const TELEGRAM_CHAT_IDS = ['1277452628'];
const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b';

(async function initializeDepositPage() {
  try {
    await fetchCoinPrices_deposit(); // Renamed to avoid conflict
    await fetchExchangeRates_deposit(); // Renamed
    await fetchUserWallets_deposit(); // Renamed
    await fetchUserDeposits_deposit(); // Renamed
    renderDepositTable_deposit(); // Renamed
    setupDepositEventListeners_deposit(); // Renamed

    const tableTotalHeader = document.getElementById('tableTotalHeader');
    if (userCurrency && tableTotalHeader) {
      tableTotalHeader.textContent = 'Total (' + userCurrency + ')';
    }
  } catch (error) {
    console.error('Deposit page initialization error:', error);
  }
})();

async function fetchCoinPrices_deposit() {
  try {
    const res = await fetch('/api/coin-prices', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Coin prices fetch failed with status: ' + res.status);
    }
    coinPrices = await res.json();
  } catch (err) {
    console.error('Error fetching coin prices:', err);
    coinPrices = {};
  }
}

async function fetchExchangeRates_deposit() {
  try {
    const url = 'https://v6.exchangerate-api.com/v6/' + EXCHANGE_RATE_API_KEY + '/latest/USD';
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('Exchange rate fetch failed: ' + res.status);
    }
    const data = await res.json();
    if (data.result === 'success') {
        exchangeRates = data.conversion_rates || {};
    } else {
        console.error("ExchangeRate-API success false:", data['error-type']);
        exchangeRates = {};
    }
  } catch (error) {
    console.error('Error fetching exchange rates:', error);
    exchangeRates = {};
  }
}

async function fetchUserWallets_deposit() {
  if (!depositCurrentUser || !depositCurrentUser.id) {
    console.error("Cannot fetch user wallets, user not authenticated.");
    userWallets = [];
    return;
  }
  try {
    const res = await fetch('/api/user/' + depositCurrentUser.id + '/wallets', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch user wallets: ' + res.status);
    }
    userWallets = await res.json();
  } catch (error) {
    console.error('Error fetching wallets:', error);
    userWallets = [];
  }
}

async function fetchUserDeposits_deposit() {
  if (!depositCurrentUser || !depositCurrentUser.id) {
    console.error("Cannot fetch user deposits, user not authenticated.");
    deposits = [];
    return;
  }
  try {
    const res = await fetch('/api/user/' + depositCurrentUser.id + '/deposits', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch deposits: ' + res.status);
    }
    deposits = await res.json();
  } catch (error) {
    console.error('Error fetching deposits:', error);
    deposits = [];
  }
}

function renderDepositTable_deposit() {
  const tbody = document.querySelector('#depositTable tbody');
  if (!tbody) return;
  tbody.innerHTML = '';

  const searchInputEl = document.getElementById('searchInput');
  const statusFilterEl = document.getElementById('statusFilter');

  const searchTerm = searchInputEl ? searchInputEl.value.toLowerCase().trim() : '';
  const filterStatus = statusFilterEl ? statusFilterEl.value : '';


  const sortedDeposits = [...deposits].sort((a, b) => new Date(b.createdAt || b.date) - new Date(a.createdAt || a.date));

  const filtered = sortedDeposits.filter(dep => {
    let matchesStatus = true;
    if (filterStatus) {
        if (filterStatus === 'pending_user_confirmation' && dep.status !== 'pending_user_confirmation') matchesStatus = false;
        else if (filterStatus === 'pending_approval' && dep.admin_status !== 'pending_approval' && dep.status === 'pending_user_confirmation') matchesStatus = false;
        else if (filterStatus === 'confirmed' && dep.status !== 'confirmed') matchesStatus = false;
        else if (filterStatus === 'rejected_by_admin' && dep.status !== 'rejected_by_admin') matchesStatus = false;
        else if (filterStatus === 'canceled' && dep.status !== 'canceled') matchesStatus = false;
        else if (filterStatus === 'pending_approval' && !(dep.status === 'pending_user_confirmation' && dep.admin_status === 'pending_approval')) matchesStatus = false;
    }

    const combinedSearchable = (dep.reference + ' ' + dep.method + ' ' + dep.type + ' ' + dep.admin_status + ' ' + (dep.admin_remarks || '')).toLowerCase();
    const matchesSearch = !searchTerm || combinedSearchable.includes(searchTerm);

    return matchesStatus && matchesSearch;
  });

  filtered.forEach(dep => {
    const tr = document.createElement('tr');

    ['id', 'date', 'reference', 'method', 'type', 'amount'].forEach(key => {
        const td = document.createElement('td');
        td.textContent = key === 'date' ? formatDate_deposit(dep[key]) : dep[key] || 'N/A';
        tr.appendChild(td);
    });
    
    const tdTotal = document.createElement('td');
    const shortName = dep.method;
    const coinKey = guessCoinGeckoKey_deposit(shortName);
    const coinUSDPrice = coinPrices[coinKey]?.usd ?? ( (shortName ==='USDT' || shortName === 'USDC') ? 1 : 0);
    const amountCrypto = parseFloat(dep.amount);
    const totalUSD = amountCrypto * coinUSDPrice;
    const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
    const totalLocal = totalUSD * rate;
    tdTotal.textContent = totalLocal.toFixed(2) + ' ' + userCurrency;
    tr.appendChild(tdTotal);

    const tdUserStatus = document.createElement('td');
    tdUserStatus.textContent = dep.status;
    tdUserStatus.className = 'status-' + dep.status.toLowerCase().replace(/\s+/g, '_');
    tr.appendChild(tdUserStatus);

    const tdAdminStatus = document.createElement('td');
    tdAdminStatus.textContent = dep.admin_status || 'N/A';
    tdAdminStatus.className = 'status-' + (dep.admin_status || '').toLowerCase().replace(/\s+/g, '_');
    tr.appendChild(tdAdminStatus);

    const tdApprovedAmount = document.createElement('td');
    if (dep.admin_status === 'approved' || dep.admin_status === 'rejected') {
        tdApprovedAmount.textContent = dep.admin_approved_amount !== null ? dep.admin_approved_amount : 'N/A';
    } else {
        tdApprovedAmount.textContent = 'N/A';
    }
    tr.appendChild(tdApprovedAmount);
    
    const tdAdminRemarks = document.createElement('td');
    tdAdminRemarks.textContent = dep.admin_remarks || 'N/A';
    if (dep.admin_remarks && dep.admin_remarks.length > 30) {
        tdAdminRemarks.title = dep.admin_remarks;
        tdAdminRemarks.textContent = dep.admin_remarks.substring(0, 27) + '...';
    }
    tr.appendChild(tdAdminRemarks);

    tbody.appendChild(tr);
  });
}

function setupDepositEventListeners_deposit() {
  const searchInputEl = document.getElementById('searchInput');
  const statusFilterEl = document.getElementById('statusFilter');
  const openDepositBtnEl = document.getElementById('openDepositBtn');
  const modalCloseBtnEl = document.getElementById('modalCloseBtn'); // This ID is shared with other modals
  const copyAddressBtnEl = document.getElementById('copyAddressBtn');
  const copyConfirmAddressBtnEl = document.getElementById('copyConfirmAddressBtn');
  const depositMethodEl = document.getElementById('depositMethod');
  const depositAmountEl = document.getElementById('depositAmount');
  const depositFormEl = document.getElementById('depositForm');

  if(searchInputEl) searchInputEl.addEventListener('input', renderDepositTable_deposit);
  if(statusFilterEl) statusFilterEl.addEventListener('change', renderDepositTable_deposit);
  if(openDepositBtnEl) openDepositBtnEl.addEventListener('click', openDepositModal_deposit);
  
  // For shared modal close button, ensure it only closes the deposit modal if it's the active one
  if(modalCloseBtnEl && document.getElementById('depositModalOverlay')) {
     modalCloseBtnEl.addEventListener('click', () => {
        if (document.getElementById('depositModalOverlay').style.display === 'flex') {
            closeDepositModal_deposit();
        }
     });
  }

  if(copyAddressBtnEl) copyAddressBtnEl.addEventListener('click', copyWalletAddress_deposit);
  if(copyConfirmAddressBtnEl) copyConfirmAddressBtnEl.addEventListener('click', copyConfirmWalletAddress_deposit);
  if(depositMethodEl) depositMethodEl.addEventListener('change', onChangeCoinMethod_deposit);
  if(depositAmountEl) depositAmountEl.addEventListener('input', updateLocalCurrencyEquivalent_deposit);
  if(depositFormEl) depositFormEl.addEventListener('submit', onDepositFormSubmit_deposit);
}

function openDepositModal_deposit() {
  const form = document.getElementById('depositForm');
  const confirmationSection = document.getElementById('confirmationSection');
  const depositModalOverlayEl = document.getElementById('depositModalOverlay');
  const localCurrencyLabelEl = document.getElementById('localCurrencyLabel');

  if (!form || !confirmationSection || !depositModalOverlayEl || !localCurrencyLabelEl) return;

  form.style.display = 'flex';
  form.reset();
  confirmationSection.style.display = 'none';
  populateMethodDropdown_deposit();
  localCurrencyLabelEl.textContent = userCurrency;
  onChangeCoinMethod_deposit();
  depositModalOverlayEl.style.display = 'flex';
}

function closeDepositModal_deposit() {
  const depositModalOverlayEl = document.getElementById('depositModalOverlay');
  if(depositModalOverlayEl) depositModalOverlayEl.style.display = 'none';
}

function populateMethodDropdown_deposit() {
  const methodSelect = document.getElementById('depositMethod');
  const depositAddressInput = document.getElementById('depositAddress');
  if(!methodSelect || !depositAddressInput) return;
  methodSelect.innerHTML = ''; 

  const depositableWallets = userWallets.filter(wallet => {
    const coinKey = guessCoinGeckoKey_deposit(wallet.shortName);
    return coinPrices.hasOwnProperty(coinKey) || wallet.shortName === 'USDT' || wallet.shortName === 'USDC';
  });

  if (depositableWallets.length === 0) {
    const option = document.createElement('option');
    option.value = '';
    option.textContent = 'No depositable wallets';
    option.disabled = true;
    methodSelect.appendChild(option);
    depositAddressInput.value = '';
    return;
  }

  depositableWallets.forEach(wallet => {
    const option = document.createElement('option');
    option.value = wallet.shortName; 
    option.textContent = wallet.coinName + ' (' + wallet.shortName + ')';
    option.setAttribute('data-address', wallet.walletAddress);
    methodSelect.appendChild(option);
  });
  onChangeCoinMethod_deposit(); 
}

function onChangeCoinMethod_deposit() {
  const methodSelect = document.getElementById('depositMethod');
  const depositAddressInput = document.getElementById('depositAddress');
  if(!methodSelect || !depositAddressInput) return;

  if (methodSelect.options.length > 0 && methodSelect.selectedIndex !== -1) {
    const selectedOption = methodSelect.options[methodSelect.selectedIndex];
    const address = selectedOption.getAttribute('data-address') || '';
    depositAddressInput.value = address;
  } else {
     depositAddressInput.value = 'No wallet selected or available';
  }
  updateLocalCurrencyEquivalent_deposit();
}

function copyWalletAddress_deposit() {
  const addressField = document.getElementById('depositAddress');
  if (!addressField) return;
  navigator.clipboard.writeText(addressField.value)
    .then(() => alert('Address copied!'))
    .catch(err => {
      console.error('Failed to copy address:', err);
      alert('Failed to copy.');
    });
}

function copyConfirmWalletAddress_deposit() {
  const addressTextEl = document.getElementById('confirmAddress');
  if (!addressTextEl) return;
  const addressText = addressTextEl.textContent;
  navigator.clipboard.writeText(addressText)
    .then(() => alert('Address copied!'))
    .catch(err => {
      console.error('Failed to copy address:', err);
      alert('Failed to copy.');
    });
}

function updateLocalCurrencyEquivalent_deposit() {
  const amountStrEl = document.getElementById('depositAmount');
  const methodSelectEl = document.getElementById('depositMethod');
  const localCurrencyEquivalentInputEl = document.getElementById('localCurrencyEquivalent');
  
  if(!amountStrEl || !methodSelectEl || !localCurrencyEquivalentInputEl) return;

  const amountStr = amountStrEl.value;
  
  if (!methodSelectEl.value) {
      localCurrencyEquivalentInputEl.value = '';
      return;
  }
  const shortName = methodSelectEl.value; 

  if (!amountStr) {
    localCurrencyEquivalentInputEl.value = '';
    return;
  }

  const amountCrypto = parseFloat(amountStr);
  if (isNaN(amountCrypto) || amountCrypto <= 0) {
    localCurrencyEquivalentInputEl.value = '';
    return;
  }

  const coinKey = guessCoinGeckoKey_deposit(shortName);
  const coinUSDPrice = coinPrices[coinKey]?.usd ?? ( (shortName ==='USDT' || shortName === 'USDC') ? 1 : 0);

  if(coinUSDPrice === 0 && shortName !== 'USDT' && shortName !== 'USDC'){
      console.warn('Price for ' + shortName + ' (key: ' + coinKey + ') not found. Cannot calculate local equivalent.');
      localCurrencyEquivalentInputEl.value = 'Price N/A';
      return;
  }
  
  const totalUSD = coinUSDPrice * amountCrypto;
  const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
  const localValue = totalUSD * rate;

  localCurrencyEquivalentInputEl.value = localValue.toFixed(2);
}

function guessCoinGeckoKey_deposit(shortName) {
  if (!shortName) return 'usd-coin';
  const upperShortName = shortName.toUpperCase();
  const mapping = {
    'BTC': 'bitcoin', 'ETH': 'ethereum', 'BNB': 'binancecoin', 
    'DOGE': 'dogecoin', 'USDT': 'tether', 'USDC': 'usd-coin',
    'XRP': 'ripple', 'ADA': 'cardano', 'SOL': 'solana', 
    'AVAX': 'avalanche-2', 'SHIB': 'shiba-inu', 'LTC': 'litecoin',
    'TRX': 'tron', 'MATIC': 'polygon', 'PEPE': 'pepe'
  };
  return mapping[upperShortName] || shortName.toLowerCase();
}

async function onDepositFormSubmit_deposit(e) {
  e.preventDefault();
  const confirmDepositBtnEl = document.getElementById('confirmDepositBtn');
  if(confirmDepositBtnEl) confirmDepositBtnEl.disabled = true;

  const depositForm = document.getElementById('depositForm');
  const confirmationSection = document.getElementById('confirmationSection');
  const depositTypeEl = document.getElementById('depositType');      
  const methodSelectEl = document.getElementById('depositMethod');
  const depositAddressEl = document.getElementById('depositAddress');
  const depositAmountEl = document.getElementById('depositAmount');
  const localEquivalentEl = document.getElementById('localCurrencyEquivalent');

  if (!depositForm || !confirmationSection || !depositTypeEl || !methodSelectEl || !depositAddressEl || !depositAmountEl || !localEquivalentEl) {
    if(confirmDepositBtnEl) confirmDepositBtnEl.disabled = false;
    return;
  }
  
  const depositType = depositTypeEl.value;      
  const coinShortName = methodSelectEl.value;
  const coinFullName = methodSelectEl.options[methodSelectEl.selectedIndex]?.textContent.split(' (')[0] || coinShortName;
  const depositAddress = depositAddressEl.value;
  const depositAmount = depositAmountEl.value;
  const localEquivalent = localEquivalentEl.value;

  if (!coinShortName || !depositAmount || parseFloat(depositAmount) <= 0 || !depositAddress || depositAddress === 'No wallet selected or available') {
    alert('Please select a coin, enter a valid amount, and ensure a wallet address is available.');
    if(confirmDepositBtnEl) confirmDepositBtnEl.disabled = false;
    return;
  }

  const payload = {
    userId: depositCurrentUser.id,
    method: coinShortName,
    type: depositType,        
    amount: depositAmount,    
    totalEUR: localEquivalent,
  };

  try {
    // showLoading(); // Use main dashboard loading
    const createRes = await fetch('/api/deposits', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(payload)
    });
    if (!createRes.ok) {
      const errData = await createRes.json();
      throw new Error(errData.error || 'Deposit create failed: ' + createRes.status);
    }
    const createData = await createRes.json();
    const backendReference = createData.reference;

    const textMsg = 'New deposit initiated by User ' + depositCurrentUser.id + ' (' + depositCurrentUser.email + '):\nReference: ' + backendReference + '\nAmount: ' + depositAmount + ' ' + coinShortName + ' (' + coinFullName + ')\nUser\'s Wallet Address for Deposit: ' + depositAddress + ' \nStatus: pending_user_confirmation / admin_status: pending_approval';

    for (const chatId of TELEGRAM_CHAT_IDS) {
      await sendTelegramMessage_deposit(chatId, textMsg);
    }

    const notePayload = {
      message: 'Your deposit request (Ref: ' + backendReference + ') for ' + depositAmount + ' ' + coinShortName + ' is pending user confirmation and admin approval.'
    };
    await fetch('/api/user/' + depositCurrentUser.id + '/notifications', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(notePayload)
    });

    depositForm.style.display = 'none';
    document.getElementById('confirmRef').textContent = backendReference;
    document.getElementById('confirmAmountCrypto').textContent = depositAmount + ' ' + coinShortName;
    document.getElementById('confirmAmountLocal').textContent = localEquivalent + ' ' + userCurrency;
    document.getElementById('confirmAddress').textContent = depositAddress;
    confirmationSection.style.display = 'block';

    const newDepositEntry = {
        id: createData.depositId,
        date: new Date().toISOString(),
        reference: backendReference,
        method: coinShortName,
        type: depositType,
        amount: depositAmount,
        totalEUR: localEquivalent,
        status: 'pending_user_confirmation',
        admin_status: 'pending_approval',   
        admin_approved_amount: depositAmount,
        admin_remarks: null,
        createdAt: new Date().toISOString()
    };
    deposits.push(newDepositEntry);
    renderDepositTable_deposit();

  } catch (error) {
    alert('Error creating deposit: ' + error.message);
    console.error('Error on deposit creation:', error);
  } finally {
    // hideLoading(); // Use main dashboard loading
    if(confirmDepositBtnEl) confirmDepositBtnEl.disabled = false;
  }
}

async function sendTelegramMessage_deposit(chatId, text) {
  const url = 'https://api.telegram.org/bot' + TELEGRAM_BOT_TOKEN + '/sendMessage';
  const body = {
    chat_id: chatId,
    text
  };
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!response.ok) {
        console.error("Telegram API error:", await response.json());
    }
  } catch (err) {
    console.error('Failed to send Telegram message:', err);
  }
}

function formatDate_deposit(dateString) {
  if (!dateString) return 'N/A';
  try {
    const d = new Date(dateString);
    if (isNaN(d.getTime())) {
        return 'Invalid Date';
    }
    return d.toLocaleString(); 
  } catch (e) {
    return dateString;
  }
}

scripts/markets.js
/**
 * Markets Page Functionality
 * Handles all markets-related operations
 */

// Markets functionality
let marketsCurrentUser = window.currentUser; // Use the global currentUser
let userWallets_markets = []; // Scoped
let coinPricesUSD_markets = {}; // Scoped
let exchangeRates_markets = {}; // Scoped
let userCurrency_markets = marketsCurrentUser?.accountCurrency || 'USD';

const allAssets_markets = [ // Renamed
  { symbol: 'AAPL',  name: 'Apple',                    type: 'Stocks' },
  { symbol: 'AAVE',  name: 'AAVE',                     type: 'Crypto' },
  { symbol: 'ABT',   name: 'Abbot Labs',               type: 'Stocks' },
  { symbol: 'ADA',   name: 'Cardano',                  type: 'Crypto' },
  { symbol: 'ADBE',  name: 'Adobe',                    type: 'Stocks' },
  { symbol: 'ALGO',  name: 'Algorand',                 type: 'Crypto' },
  { symbol: 'AMZN',  name: 'Amazon',                   type: 'Stocks' },
  { symbol: 'AUD',   name: 'Australian Dollar',        type: 'Fiat'   },
  { symbol: 'AVAX',  name: 'Avalanche',                type: 'Crypto' },
  { symbol: 'AXS',   name: 'Axie Infinity',            type: 'Crypto' },
  { symbol: 'BABA',  name: 'Alibaba',                  type: 'Stocks' },
  { symbol: 'BAC',   name: 'Bank of America',          type: 'Stocks' },
  { symbol: 'BCH',   name: 'Bitcoin Cash',             type: 'Crypto' },
  { symbol: 'BTC',   name: 'Bitcoin',                  type: 'Crypto' },
  { symbol: 'CAD',   name: 'Canadian Dollar',          type: 'Fiat'   },
  { symbol: 'CHF',   name: 'Swiss Franc',              type: 'Fiat'   },
  { symbol: 'CRO',   name: 'Cronos',                   type: 'Crypto' },
  { symbol: 'DAI',   name: 'Dai',                      type: 'Crypto' },
  { symbol: 'DOGE',  name: 'Dogecoin',                 type: 'Crypto' },
  { symbol: 'DOT',   name: 'Polkadot',                 type: 'Crypto' },
  { symbol: 'ETH',   name: 'Ethereum',                 type: 'Crypto' },
  { symbol: 'EUR',   name: 'Euro',                     type: 'Fiat'   },
  { symbol: 'FB',    name: 'Meta Platforms Inc',       type: 'Stocks' },
  { symbol: 'GBP',   name: 'British Pound',            type: 'Fiat'   },
  { symbol: 'GOOGL', name: 'Google',                   type: 'Stocks' },
  { symbol: 'LTC',   name: 'Litecoin',                 type: 'Crypto' },
  { symbol: 'MATIC', name: 'Polygon',                  type: 'Crypto' },
  { symbol: 'MSFT',  name: 'Microsoft',                type: 'Stocks' },
  { symbol: 'PEPE',  name: 'Pepe',                     type: 'Crypto' },
  { symbol: 'SOL',   name: 'Solana',                   type: 'Crypto' },
  { symbol: 'TSLA',  name: 'Tesla',                    type: 'Stocks' },
  { symbol: 'UNI',   name: 'Uniswap',                  type: 'Crypto' },
  { symbol: 'USD',   name: 'United States Dollar',     type: 'Fiat'   },
  { symbol: 'USDC',  name: 'USD Coin',                 type: 'Crypto' },
  { symbol: 'USDT',  name: 'Tether',                   type: 'Crypto' },
  { symbol: 'XRP',   name: 'Ripple',                   type: 'Crypto' }
];

const coinGeckoMap_markets = { // Renamed
  BTC: 'bitcoin',
  ETH: 'ethereum',
  USDC: 'usd-coin',
  USDT: 'tether',
  BNB: 'binancecoin',
  ADA: 'cardano',
  DOGE: 'dogecoin',
  SOL: 'solana',
  AVAX: 'avalanche-2',
  SHIB: 'shiba-inu',
  LTC: 'litecoin',
  TRX: 'tron',
  MATIC: 'matic-network',
  PEPE: 'pepe',
  XRP: 'ripple',
  CRO: 'crypto-com-chain',
  DAI: 'dai',
  UNI: 'uniswap',
  AAVE: 'aave',
  ALGO: 'algorand',
  BCH: 'bitcoin-cash',
  AXS: 'axie-infinity'
};

(async function initializeMarketsPage() {
  try {
    await fetchCoinPrices_markets();
    await fetchExchangeRates_markets();
    await fetchUserWallets_markets();

    const searchBarEl = document.getElementById('searchBar');
    const filterSelectEl = document.getElementById('filterSelect');

    if(searchBarEl) searchBarEl.addEventListener('input', renderTable_markets);
    if(filterSelectEl) filterSelectEl.addEventListener('change', renderTable_markets);

    renderTable_markets();

  } catch (error) {
    console.error('Markets page initialization error:', error);
  }
})();

async function fetchCoinPrices_markets() {
  try {
    const res = await fetch('/api/coin-prices', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch coin prices: ' + res.status);
    }
    coinPricesUSD_markets = await res.json();
  } catch (err) {
    console.error('Error fetching coin prices:', err);
    coinPricesUSD_markets = {};
  }
}

async function fetchExchangeRates_markets() {
  const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b'; 
  const url = 'https://v6.exchangerate-api.com/v6/' + EXCHANGE_RATE_API_KEY + '/latest/USD';
  try {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('Exchange rate fetch failed: ' + res.status);
    }
    const data = await res.json();
    exchangeRates_markets = data.conversion_rates || {};
  } catch (err) {
    console.error('Error fetching exchange rates:', err);
    exchangeRates_markets = {};
  }
}

async function fetchUserWallets_markets() {
  try {
    const res = await fetch('/api/user/' + marketsCurrentUser.id + '/wallets', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch user wallets: ' + res.status);
    }
    userWallets_markets = await res.json();
  } catch (err) {
    console.error('Error fetching wallets:', err);
    userWallets_markets = [];
  }
}

function renderTable_markets() {
  const searchBarEl = document.getElementById('searchBar');
  const filterSelectEl = document.getElementById('filterSelect');
  const assetsTableBodyEl = document.getElementById('assetsTableBody');

  if(!searchBarEl || !filterSelectEl || !assetsTableBodyEl) return;

  const searchQuery = searchBarEl.value.toLowerCase();
  const filterType = filterSelectEl.value;
  const starredSymbols = getStarredAssets_markets();

  let filtered = allAssets_markets.filter(a => {
    const matchesSearch = a.name.toLowerCase().includes(searchQuery) ||
                          a.symbol.toLowerCase().includes(searchQuery);
    const matchesFilter = (filterType === 'All') || (a.type === filterType);
    return matchesSearch && matchesFilter;
  });

  filtered.sort((a, b) => {
    const aStar = starredSymbols.includes(a.symbol);
    const bStar = starredSymbols.includes(b.symbol);
    if (aStar && !bStar) return -1;
    if (!aStar && bStar) return 1;
    return a.name.localeCompare(b.name);
  });

  assetsTableBodyEl.innerHTML = '';

  for (let asset of filtered) {
    const tr = document.createElement('tr');

    const starTd = document.createElement('td');
    const starIcon = document.createElement('span');
    starIcon.textContent = '★';
    starIcon.classList.add('star'); // Defined in main.css or here
    if (starredSymbols.includes(asset.symbol)) {
      starIcon.classList.add('filled'); // Defined in main.css or here
    }
    starIcon.onclick = () => toggleStar_markets(asset.symbol);
    starTd.appendChild(starIcon);
    tr.appendChild(starTd);

    const nameTd = document.createElement('td');
    nameTd.textContent = asset.name;
    tr.appendChild(nameTd);

    const typeTd = document.createElement('td');
    typeTd.textContent = asset.type;
    tr.appendChild(typeTd);

    let priceEur = 0;
    if (asset.type === 'Crypto') {
      const usdPrice = getUsdPriceFromShortName_markets(asset.symbol);
      const eurRate = exchangeRates_markets['EUR'] || 1;
      priceEur = usdPrice * eurRate;
    } else if (asset.type === 'Fiat') {
      priceEur = (asset.symbol === 'EUR') ? 1 : 0;
    } else {
      priceEur = 0;
    }
    const priceTd = document.createElement('td');
    priceTd.textContent = '€' + formatNumber_markets(priceEur) + '/' + asset.symbol;
    tr.appendChild(priceTd);

    let userBalance = '0.00';
    const foundWallet = userWallets_markets.find(w => w.shortName.toUpperCase() === asset.symbol.toUpperCase());
    if (foundWallet && foundWallet.balance) {
      userBalance = foundWallet.balance;
    }
    const walletTd = document.createElement('td');
    walletTd.textContent = userBalance + ' ' + asset.symbol;
    tr.appendChild(walletTd);

    const actionTd = document.createElement('td');
    const tradeBtn = document.createElement('button');
    tradeBtn.textContent = 'Trade';
    tradeBtn.classList.add('btn', 'btn-success'); // Use dashboard button styles
    tradeBtn.onclick = () => window.navigateToPage('trade'); // Use SPA navigation
    actionTd.appendChild(tradeBtn);
    tr.appendChild(actionTd);

    assetsTableBodyEl.appendChild(tr);
  }
}

function getStarredAssets_markets() {
  const name = 'starred=';
  const decoded = decodeURIComponent(document.cookie);
  const parts = decoded.split(';');
  for (let p of parts) {
    const c = p.trim();
    if (c.startsWith(name)) {
      return c.substring(name.length).split(',');
    }
  }
  return [];
}

function setStarredAssets_markets(arr) {
  const expires = new Date();
  expires.setFullYear(expires.getFullYear() + 1);
  document.cookie = 'starred=' + arr.join(',') + '; path=/; expires=' + expires.toUTCString();
}

function toggleStar_markets(symbol) {
  let starred = getStarredAssets_markets();
  if (starred.includes(symbol)) {
    starred = starred.filter(s => s !== symbol);
  } else {
    starred.push(symbol);
    alert('Added to watchlist');
  }
  setStarredAssets_markets(starred);
  renderTable_markets();
}

function getUsdPriceFromShortName_markets(shortName) {
  const key = guessCoinGeckoKey_markets(shortName);
  if (!coinPricesUSD_markets[key] || !coinPricesUSD_markets[key].usd) {
    return 1;
  }
  return coinPricesUSD_markets[key].usd;
}

function guessCoinGeckoKey_markets(shortName) {
  const upper = shortName.toUpperCase();
  if (coinGeckoMap_markets[upper]) return coinGeckoMap_markets[upper];
  return 'usd-coin';
}

function formatNumber_markets(num) {
  if (!num || isNaN(num)) return '0.00';
  return parseFloat(num).toLocaleString('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 6
  });
}

// Star styling for markets page (if not globally available)
if (!document.getElementById('markets-star-style')) {
    const style = document.createElement('style');
    style.id = 'markets-star-style';
    style.textContent = '.star { cursor: pointer; font-size: 18px; color: var(--text-secondary); transition: all 0.2s; } .star.filled { color: #ffd700; } .star:hover { transform: scale(1.2); }';
    document.head.appendChild(style);
}

scripts/trade.js
/**
 * Trade Page Functionality
 * Handles all trading-related operations
 */

// Trade functionality
let tradeCurrentUser = window.currentUser;
let userWallets_trade = []; // Scoped
let coinPricesUSD_trade = {}; // Scoped
let exchangeRates_trade = {}; // Scoped
let userCurrency_trade = tradeCurrentUser?.accountCurrency || 'USD';
let openTrades_trade = []; // Scoped
// let closedTrades_trade = []; // Scoped, if needed

const allCrypto_trade = [
  { symbol: 'BTC', name: 'Bitcoin' }, { symbol: 'ETH', name: 'Ethereum' },
  { symbol: 'LTC', name: 'Litecoin' }, { symbol: 'XRP', name: 'Ripple' },
  { symbol: 'ADA', name: 'Cardano' }, { symbol: 'SOL', name: 'Solana' },
  { symbol: 'MATIC', name: 'Polygon' }, { symbol: 'DOGE', name: 'Dogecoin' },
  { symbol: 'DOT', name: 'Polkadot' }, { symbol: 'BCH', name: 'Bitcoin Cash' },
  { symbol: 'AVAX', name: 'Avalanche' }, { symbol: 'ALGO', name: 'Algorand' },
  { symbol: 'AAVE', name: 'AAVE' }, { symbol: 'AXS', name: 'Axie Infinity' },
  { symbol: 'PEPE', name: 'Pepe' }, { symbol: 'UNI', name: 'Uniswap' },
  { symbol: 'LINK', name: 'Chainlink' }, { symbol: 'ATOM', name: 'Cosmos' },
  { symbol: 'XLM', name: 'Stellar' }, { symbol: 'VET', name: 'VeChain' }
];

const allStocks_trade = [
  { symbol: 'AAPL',  name: 'Apple' }, { symbol: 'TSLA',  name: 'Tesla' },
  { symbol: 'AMZN',  name: 'Amazon' }, { symbol: 'MSFT',  name: 'Microsoft' },
  { symbol: 'GOOGL', name: 'Google' }, { symbol: 'FB',    name: 'Meta' },
  { symbol: 'BABA',  name: 'Alibaba' }, { symbol: 'BAC',   name: 'Bank of America' },
  { symbol: 'ADBE',  name: 'Adobe' }
];

const fiatCurrencies_trade = ['USD','EUR','GBP','JPY','AUD','CAD','CHF'];

const cryptoLogos_trade = {
  BTC: "https://assets.coingecko.com/coins/images/1/large/bitcoin.png",
  ETH: "https://assets.coingecko.com/coins/images/279/large/ethereum.png",
  LTC: "https://assets.coingecko.com/coins/images/2/large/litecoin.png",
  XRP: "https://assets.coingecko.com/coins/images/44/large/xrp-symbol-white-128.png",
  ADA: "https://assets.coingecko.com/coins/images/975/large/cardano.png",
  SOL: "https://assets.coingecko.com/coins/images/4128/large/solana.png",
  MATIC: "https://assets.coingecko.com/coins/images/4713/large/matic-token-icon.png",
  DOGE: "https://assets.coingecko.com/coins/images/5/large/dogecoin.png",
  DOT: "https://assets.coingecko.com/coins/images/12171/large/polkadot.png",
  BCH: "https://assets.coingecko.com/coins/images/780/large/bitcoin-cash.png",
  AVAX: "https://assets.coingecko.com/coins/images/12559/large/avalanche.png",
  ALGO: "https://assets.coingecko.com/coins/images/4380/large/download.png",
  AAVE: "https://assets.coingecko.com/coins/images/12645/large/AAVE.png",
  AXS: "https://assets.coingecko.com/coins/images/13029/large/axie-infinity.png",
  PEPE: "https://assets.coingecko.com/coins/images/26139/large/pepe-logo.png",
  UNI: "https://assets.coingecko.com/coins/images/12504/large/uniswap-uni.png",
  LINK: "https://assets.coingecko.com/coins/images/877/large/chainlink-new-logo.png",
  ATOM: "https://assets.coingecko.com/coins/images/1481/large/atom.png",
  XLM: "https://assets.coingecko.com/coins/images/100/large/Stellar_symbol_black_RGB.png",
  VET: "https://assets.coingecko.com/coins/images/41/large/vechain.png"
};

const stockLogos_trade = {
  AAPL: "https://logo.clearbit.com/apple.com", TSLA: "https://logo.clearbit.com/tesla.com",
  AMZN: "https://logo.clearbit.com/amazon.com", MSFT: "https://logo.clearbit.com/microsoft.com",
  GOOGL: "https://logo.clearbit.com/google.com", FB: "https://logo.clearbit.com/meta.com",
  BABA: "https://logo.clearbit.com/alibaba.com", BAC: "https://logo.clearbit.com/bankofamerica.com",
  ADBE: "https://logo.clearbit.com/adobe.com"
};

const fiatIcons_trade = {
  USD: "attach_money", EUR: "euro_symbol", GBP: "currency_pound", JPY: "yen",
  AUD: "attach_money", CAD: "attach_money", CHF: "attach_money"
};

const coinGeckoMap_trade = {
  BTC: 'bitcoin', ETH: 'ethereum', LTC: 'litecoin', XRP: 'ripple',
  ADA: 'cardano', SOL: 'solana', MATIC: 'matic-network', DOGE: 'dogecoin',
  DOT: 'polkadot', BCH: 'bitcoin-cash', AVAX: 'avalanche-2', ALGO: 'algorand',
  AAVE: 'aave', AXS: 'axie-infinity', PEPE: 'pepe', UNI: 'uniswap',
  LINK: 'chainlink', ATOM: 'cosmos', XLM: 'stellar', VET: 'vechain'
};

function getIconUrl_trade(symbol, market) {
  if (market === 'Crypto') {
    if (cryptoLogos_trade[symbol]) return cryptoLogos_trade[symbol];
    return 'https://cryptoicon-api.vercel.app/api/icon/' + symbol.toLowerCase();
  } else if (market === 'Stocks') {
    if (stockLogos_trade[symbol]) return stockLogos_trade[symbol];
    return 'https://via.placeholder.com/24?text=S';
  } else if (market === 'Forex' || market === 'Fiat') {
    return "MATERIAL:" + (fiatIcons_trade[symbol] || "attach_money");
  }
  return 'https://via.placeholder.com/24?text=?';
}

function updateSelectedIcon_trade(elementId, symbol, market) {
  var iconEl = document.getElementById(elementId);
  if (!iconEl) return;
  var container = iconEl.parentNode;
  var iconUrl = getIconUrl_trade(symbol, market);

  if (iconUrl.indexOf("MATERIAL:") === 0) {
    var iconName = iconUrl.replace("MATERIAL:", "");
    var span = document.createElement("span");
    span.id = elementId;
    span.className = "material-icons asset-icon";
    span.style.fontSize = "24px";
    span.style.verticalAlign = "middle";
    span.textContent = iconName;
    if (iconEl.tagName.toLowerCase() === "img" || iconEl.tagName.toLowerCase() === "span") {
        container.replaceChild(span, iconEl);
    } else { // Should not happen if IDs are correct
        container.appendChild(span);
    }
  } else {
    var img;
    if (iconEl.tagName.toLowerCase() !== "img") {
      img = document.createElement("img");
      img.id = elementId;
      img.className = "asset-icon";
      container.replaceChild(img, iconEl);
    } else {
      img = iconEl;
    }
    img.src = iconUrl;
    img.alt = symbol + " icon";
    img.style.width = "24px";
    img.style.height = "24px";
    img.style.verticalAlign = "middle";
  }
}

function updateAssetPrice_trade(elementId, symbol, market) {
  var el = document.getElementById(elementId);
  if(!el) return;
  if(market === "Crypto") {
    let price = getCryptoPriceInUser_trade(symbol);
    el.textContent = "Price: " + formatNumber_trade(price) + " " + userCurrency_trade;
  } else if(market === "Stocks") {
    let price = getStockPriceInUser_trade(symbol);
    el.textContent = "Price: " + formatNumber_trade(price) + " " + userCurrency_trade;
  } else {
    el.textContent = "";
  }
}

(async function initializeTradePage_scoped() { // Renamed to avoid global conflict
  try {
    await fetchCoinPrices_trade();
    await fetchExchangeRates_trade();
    await fetchUserWallets_trade();

    initTabs_trade();
    initBuyForm_trade();
    initSellForm_trade();
    initConvertForm_trade();
  } catch (err) {
    console.error('Trade initialization error:', err);
  }
})();

async function fetchCoinPrices_trade() {
  try {
    const res = await fetch('/api/coin-prices', { credentials: 'include' });
    if (!res.ok) throw new Error('coin-prices failed: ' + res.status);
    coinPricesUSD_trade = await res.json();
  } catch (err) {
    console.error('Coin prices fetch error:', err);
    coinPricesUSD_trade = {};
  }
}

async function fetchExchangeRates_trade() {
  const key = '22b4c51015d34a6cc3fd928b';
  const url = 'https://v6.exchangerate-api.com/v6/' + key + '/latest/USD';
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('exchangeRates fetch error: ' + res.status);
    const data = await res.json();
    exchangeRates_trade = data.conversion_rates || {};
  } catch (err) {
    console.error('Exchange rate fetch error:', err);
    exchangeRates_trade = {};
  }
}

async function fetchUserWallets_trade() {
  try {
    const res = await fetch('/api/user/' + tradeCurrentUser.id + '/wallets', { credentials: 'include' });
    if (!res.ok) throw new Error('wallets fetch error: ' + res.status);
    userWallets_trade = await res.json();
  } catch (err) {
    console.error('Wallet fetch error:', err);
    userWallets_trade = [];
  }
}

function initTabs_trade() {
  const tabBuy = document.getElementById('tabBuy');
  const tabSell = document.getElementById('tabSell');
  const tabConvert = document.getElementById('tabConvert');

  const buyTabContent = document.getElementById('buyTabContent');
  const sellTabContent = document.getElementById('sellTabContent');
  const convertTabContent = document.getElementById('convertTabContent');

  if(!tabBuy || !tabSell || !tabConvert || !buyTabContent || !sellTabContent || !convertTabContent) return;

  tabBuy.addEventListener('click', () => {
    tabBuy.classList.add('active');
    tabSell.classList.remove('active');
    tabConvert.classList.remove('active');
    buyTabContent.classList.add('active');
    sellTabContent.classList.remove('active');
    convertTabContent.classList.remove('active');
  });
  tabSell.addEventListener('click', () => {
    tabSell.classList.add('active');
    tabBuy.classList.remove('active');
    tabConvert.classList.remove('active');
    sellTabContent.classList.add('active');
    buyTabContent.classList.remove('active');
    convertTabContent.classList.remove('active');
  });
  tabConvert.addEventListener('click', () => {
    tabConvert.classList.add('active');
    tabBuy.classList.remove('active');
    tabSell.classList.remove('active');
    convertTabContent.classList.add('active');
    buyTabContent.classList.remove('active');
    sellTabContent.classList.remove('active');
  });
}

function initBuyForm_trade() {
  const buyForm = document.getElementById('buyForm');
  const buyMarket = document.getElementById('buyMarket');
  const buySymbol = document.getElementById('buySymbol');
  const buyForexSection = document.getElementById('buyForexSection');
  const buySingleSymbolSection = document.getElementById('buySingleSymbolSection');
  const buyForexBase = document.getElementById('buyForexBase');
  const buyForexQuote = document.getElementById('buyForexQuote');
  const buyBalanceInfo = document.getElementById('buyBalanceInfo');
  const buyAmount = document.getElementById('buyAmount');
  const buyCostDisplay = document.getElementById('buyCostDisplay');
  const buyCurrencyLabel = document.getElementById('buyCurrencyLabel');
  const buyLeverageSlider = document.getElementById('buyLeverageSlider');
  const buyLeverageValue = document.getElementById('buyLeverageValue');
  const buyOrderType = document.getElementById('buyOrderType');
  const buyLimitPriceSection = document.getElementById('buyLimitPriceSection');
  const buyError = document.getElementById('buyError');
  const buySuccess = document.getElementById('buySuccess');
  const buyButton = document.getElementById('buyButton');

  if(!buyForm) return; // Exit if crucial elements are not found

  buyCurrencyLabel.textContent = userCurrency_trade;

  fillFiatSelect_trade(buyForexBase, "Fiat");
  fillFiatSelect_trade(buyForexQuote, "Fiat");
  if(buyForexBase.options.length > 1) buyForexBase.value = 'EUR'; else if (buyForexBase.options.length > 0) buyForexBase.value = buyForexBase.options[0].value;
  if(buyForexQuote.options.length > 0) buyForexQuote.value = 'USD'; else if (buyForexQuote.options.length > 0) buyForexQuote.value = buyForexQuote.options[0].value;
  
  updateSelectedIcon_trade("buyForexBaseIcon", buyForexBase.value, "Fiat");
  updateSelectedIcon_trade("buyForexQuoteIcon", buyForexQuote.value, "Fiat");
  
  fillAssetSelect_trade(buySymbol, 'Crypto');
  if(buySymbol.options.length > 0) {
     updateSelectedIcon_trade("buySymbolIcon", buySymbol.value, buyMarket.value);
     updateAssetPrice_trade("buyAssetPrice", buySymbol.value, buyMarket.value);
  }


  buyMarket.addEventListener('change', () => {
    if (buyMarket.value === 'Forex') {
      buyForexSection.style.display = 'block';
      buySingleSymbolSection.style.display = 'none';
    } else {
      buyForexSection.style.display = 'none';
      buySingleSymbolSection.style.display = 'block';
      fillAssetSelect_trade(buySymbol, buyMarket.value);
      if(buySymbol.options.length > 0) {
        updateSelectedIcon_trade("buySymbolIcon", buySymbol.value, buyMarket.value);
        updateAssetPrice_trade("buyAssetPrice", buySymbol.value, buyMarket.value);
      }
    }
    showBuyBalance_trade();
    calcBuyCost_trade();
    validateBuyForm_trade();
  });
  
  [buySymbol, buyForexBase, buyForexQuote, buyAmount].forEach(el => {
    el.addEventListener('change', () => {
      if (el === buySymbol) {
        updateSelectedIcon_trade("buySymbolIcon", buySymbol.value, buyMarket.value);
        updateAssetPrice_trade("buyAssetPrice", buySymbol.value, buyMarket.value);
      }
      if (el === buyForexBase) updateSelectedIcon_trade("buyForexBaseIcon", buyForexBase.value, "Fiat");
      if (el === buyForexQuote) updateSelectedIcon_trade("buyForexQuoteIcon", buyForexQuote.value, "Fiat");
      showBuyBalance_trade();
      calcBuyCost_trade();
      validateBuyForm_trade();
    });
    el.addEventListener('input', () => { // For amount input mainly
      showBuyBalance_trade();
      calcBuyCost_trade();
      validateBuyForm_trade();
    });
  });

  buyLeverageSlider.addEventListener('input', () => {
    buyLeverageValue.textContent = buyLeverageSlider.value + 'x';
  });

  buyOrderType.addEventListener('change', () => {
    if (buyOrderType.value === 'limit') {
      buyLimitPriceSection.style.display = 'block';
    } else {
      buyLimitPriceSection.style.display = 'none';
    }
  });

  buyForm.addEventListener('submit', e => {
    e.preventDefault();
    doBuyTrade_trade();
  });
}

function fillFiatSelect_trade(sel, marketForIcon) {
    if (!sel) return;
    if ($(sel).data('select2')) $(sel).select2('destroy');
    sel.innerHTML = '';
    fiatCurrencies_trade.forEach(fc => {
      const opt = document.createElement('option');
      opt.value = fc;
      opt.textContent = fc;
      opt.setAttribute('data-market', marketForIcon); // For Select2 template
      sel.appendChild(opt);
    });
    $(sel).select2({
        templateResult: formatAssetOption_trade,
        templateSelection: formatAssetOption_trade,
        minimumResultsForSearch: Infinity // No search box for fiat
    });
}

function fillAssetSelect_trade(selectEl, market) {
    if (!selectEl) return;
    if ($(selectEl).data('select2')) $(selectEl).select2('destroy');
    selectEl.innerHTML = '';
    let sourceArray = [];
    if (market === 'Crypto') sourceArray = allCrypto_trade;
    else if (market === 'Stocks') sourceArray = allStocks_trade;
    
    sourceArray.forEach(item => {
      const opt = document.createElement('option');
      opt.value = item.symbol;
      opt.textContent = item.name + ' (' + item.symbol + ')';
      opt.setAttribute('data-market', market); // For Select2 template
      selectEl.appendChild(opt);
    });
     $(selectEl).select2({
        templateResult: formatAssetOption_trade,
        templateSelection: formatAssetOption_trade,
         minimumResultsForSearch: sourceArray.length > 10 ? 0 : Infinity
    });
}

function formatAssetOption_trade(option) {
    if (!option.id) return option.text;
    var market = $(option.element).data('market');
    var logoUrl = getIconUrl_trade(option.id, market);
    var $option;
    if (logoUrl.indexOf("MATERIAL:") === 0) {
        var iconName = logoUrl.replace("MATERIAL:", "");
        $option = $('<span><span class="material-icons" style="font-size:20px; margin-right:5px; vertical-align: middle;">' + iconName + '</span>' + option.text + '</span>');
    } else {
        $option = $('<span><img src="' + logoUrl + '" style="width:20px; height:20px; margin-right:5px; vertical-align: middle; border-radius:50%;" /> ' + option.text + '</span>');
    }
    return $option;
}


function showBuyBalance_trade() {
  const buyBalanceInfo = document.getElementById('buyBalanceInfo');
  if(!buyBalanceInfo) return;
  const wallet = getWallet_trade(userCurrency_trade);
  const bal = wallet ? wallet.balance : 0;
  buyBalanceInfo.textContent = 'Your ' + userCurrency_trade + ' balance: ' + formatNumber_trade(bal);
}

function calcBuyCost_trade() {
  const buyError = document.getElementById('buyError');
  const buySuccess = document.getElementById('buySuccess');
  const buyMarket = document.getElementById('buyMarket');
  const buyForexBase = document.getElementById('buyForexBase');
  const buyForexQuote = document.getElementById('buyForexQuote');
  const buySymbol = document.getElementById('buySymbol');
  const buyAmount = document.getElementById('buyAmount');
  const buyCostDisplay = document.getElementById('buyCostDisplay');

  if(!buyError || !buySuccess || !buyMarket || !buyAmount || !buyCostDisplay) return;
  
  resetMessages_trade(buyError, buySuccess);
  let priceInUser = 0;

  if (buyMarket.value === 'Forex') {
    if(!buyForexBase || !buyForexQuote) return;
    const base = buyForexBase.value;
    const quote = buyForexQuote.value;
    if (base === quote) {
      buyCostDisplay.value = '0';
      return;
    }
    priceInUser = getForexPriceInUser_trade(base, quote);
  } else if (buyMarket.value === 'Crypto') {
    if(!buySymbol) return;
    const assetSymbol = buySymbol.value;
    priceInUser = getCryptoPriceInUser_trade(assetSymbol);
  } else if (buyMarket.value === 'Stocks') {
    if(!buySymbol) return;
    const assetSymbol = buySymbol.value;
    priceInUser = getStockPriceInUser_trade(assetSymbol);
  }

  const amt = parseFloat(buyAmount.value) || 0;
  const total = amt * priceInUser;
  buyCostDisplay.value = formatNumber_trade(total);
}

function validateBuyForm_trade() {
  const buyButton = document.getElementById('buyButton');
  const buyAmount = document.getElementById('buyAmount');
  const buyMarket = document.getElementById('buyMarket');
  const buyForexBase = document.getElementById('buyForexBase');
  const buyForexQuote = document.getElementById('buyForexQuote');

  if(!buyButton || !buyAmount || !buyMarket) return;

  const amt = parseFloat(buyAmount.value) || 0;
  if (amt <= 0) {
    buyButton.disabled = true;
    return;
  }
  if (buyMarket.value === 'Forex') {
    if(!buyForexBase || !buyForexQuote) { buyButton.disabled = true; return; }
    if (buyForexBase.value === buyForexQuote.value) {
      buyButton.disabled = true;
      return;
    }
  }
  buyButton.disabled = false;
}

function doBuyTrade_trade() {
  const buyError = document.getElementById('buyError');
  const buySuccess = document.getElementById('buySuccess');
  const buyButton = document.getElementById('buyButton');
  const buyAmount = document.getElementById('buyAmount');
  const buyMarket = document.getElementById('buyMarket');
  const buyForexBase = document.getElementById('buyForexBase');
  const buyForexQuote = document.getElementById('buyForexQuote');
  const buySymbol = document.getElementById('buySymbol');
  const buyOrderType = document.getElementById('buyOrderType');
  const buyLimitPrice = document.getElementById('buyLimitPrice');
  const buyLeverageSlider = document.getElementById('buyLeverageSlider');

  if(!buyError || !buySuccess || !buyButton || !buyAmount || !buyMarket || !buyOrderType || !buyLeverageSlider) return;

  startButtonLoading_trade(buyButton);
  resetMessages_trade(buyError, buySuccess);

  const amt = parseFloat(buyAmount.value) || 0;
  if (amt <= 0) {
    buyError.textContent = 'Invalid amount.';
    buyError.style.display = 'block';
    stopButtonLoading_trade(buyButton);
    return;
  }

  const market = buyMarket.value;
  let assetSymbol = '';
  let unitPrice = 0;

  if (market === 'Forex') {
    if(!buyForexBase || !buyForexQuote) { stopButtonLoading_trade(buyButton); return; }
    const base = buyForexBase.value;
    const quote = buyForexQuote.value;
    if (base === quote) {
      buyError.textContent = 'Invalid pair.';
      buyError.style.display = 'block';
      stopButtonLoading_trade(buyButton);
      return;
    }
    assetSymbol = base + '/' + quote;
    unitPrice = getForexPriceInUser_trade(base, quote);
  } else if (market === 'Crypto') {
    if(!buySymbol) { stopButtonLoading_trade(buyButton); return; }
    assetSymbol = buySymbol.value;
    unitPrice = getCryptoPriceInUser_trade(assetSymbol);
  } else if (market === 'Stocks') {
    if(!buySymbol) { stopButtonLoading_trade(buyButton); return; }
    assetSymbol = buySymbol.value;
    unitPrice = getStockPriceInUser_trade(assetSymbol);
  }
  
  if (buyOrderType.value === 'limit') {
    if(!buyLimitPrice) { stopButtonLoading_trade(buyButton); return; }
    const limitPriceVal = parseFloat(buyLimitPrice.value) || 0;
    if (limitPriceVal <= 0) {
      buyError.textContent = 'Invalid limit price.';
      buyError.style.display = 'block';
      stopButtonLoading_trade(buyButton);
      return;
    }
    unitPrice = limitPriceVal; // Override with limit price
  }


  const cost = amt * unitPrice;
  const payWallet = getWallet_trade(userCurrency_trade);
  if (!payWallet || payWallet.balance < cost) {
    buyError.textContent = 'Insufficient ' + userCurrency_trade + ' balance.';
    buyError.style.display = 'block';
    stopButtonLoading_trade(buyButton);
    return;
  }
  // Simulate balance update (in a real app, this would be an API call)
  payWallet.balance -= cost;

  let assetWallet = getWallet_trade(assetSymbol);
  if (!assetWallet) {
    assetWallet = { shortName: assetSymbol, balance: 0 };
    userWallets_trade.push(assetWallet);
  }
  assetWallet.balance += amt;

  const newTrade = {
    id: Date.now(),
    date: new Date().toLocaleString(),
    market,
    symbol: assetSymbol,
    direction: 'Buy',
    amount: amt,
    leverage: buyLeverageSlider.value + 'x',
    entryPrice: formatNumber_trade(unitPrice) + ' ' + userCurrency_trade,
    exitPrice: '–'
  };
  openTrades_trade.push(newTrade);

  buySuccess.textContent = 'Buy executed: ' + amt + ' ' + assetSymbol + ' @ ~' + formatNumber_trade(unitPrice) + ' ' + userCurrency_trade;
  buySuccess.style.display = 'block';
  showBuyBalance_trade();
  calcBuyCost_trade();
  stopButtonLoading_trade(buyButton);
}

function initSellForm_trade() {
  const sellForm = document.getElementById('sellForm');
  const sellMarket = document.getElementById('sellMarket');
  const sellSymbol = document.getElementById('sellSymbol');
  const sellForexSection = document.getElementById('sellForexSection');
  const sellSingleSymbolSection = document.getElementById('sellSingleSymbolSection');
  const sellForexBase = document.getElementById('sellForexBase');
  const sellForexQuote = document.getElementById('sellForexQuote');
  const sellBalanceInfo = document.getElementById('sellBalanceInfo');
  const sellAmount = document.getElementById('sellAmount');
  const sellValueDisplay = document.getElementById('sellValueDisplay');
  const sellCurrencyLabel = document.getElementById('sellCurrencyLabel');
  const sellLeverageSlider = document.getElementById('sellLeverageSlider');
  const sellLeverageValue = document.getElementById('sellLeverageValue');
  const sellOrderType = document.getElementById('sellOrderType');
  const sellLimitPriceSection = document.getElementById('sellLimitPriceSection');
  const sellError = document.getElementById('sellError');
  const sellSuccess = document.getElementById('sellSuccess');
  const sellButton = document.getElementById('sellButton');

  if(!sellForm) return;

  sellCurrencyLabel.textContent = userCurrency_trade;

  fillFiatSelect_trade(sellForexBase, "Fiat");
  fillFiatSelect_trade(sellForexQuote, "Fiat");
  if(sellForexBase.options.length > 1) sellForexBase.value = 'EUR'; else if (sellForexBase.options.length > 0) sellForexBase.value = sellForexBase.options[0].value;
  if(sellForexQuote.options.length > 0) sellForexQuote.value = 'USD'; else if (sellForexQuote.options.length > 0) sellForexQuote.value = sellForexQuote.options[0].value;

  updateSelectedIcon_trade("sellForexBaseIcon", sellForexBase.value, "Fiat");
  updateSelectedIcon_trade("sellForexQuoteIcon", sellForexQuote.value, "Fiat");

  fillAssetSelect_trade(sellSymbol, 'Crypto');
  if(sellSymbol.options.length > 0) {
    updateSelectedIcon_trade("sellSymbolIcon", sellSymbol.value, sellMarket.value);
    updateAssetPrice_trade("sellAssetPrice", sellSymbol.value, sellMarket.value);
  }

  sellMarket.addEventListener('change', () => {
    if (sellMarket.value === 'Forex') {
      sellForexSection.style.display = 'block';
      sellSingleSymbolSection.style.display = 'none';
    } else {
      sellForexSection.style.display = 'none';
      sellSingleSymbolSection.style.display = 'block';
      fillAssetSelect_trade(sellSymbol, sellMarket.value);
       if(sellSymbol.options.length > 0) {
            updateSelectedIcon_trade("sellSymbolIcon", sellSymbol.value, sellMarket.value);
            updateAssetPrice_trade("sellAssetPrice", sellSymbol.value, sellMarket.value);
       }
    }
    showSellBalance_trade();
    calcSellValue_trade();
    validateSellForm_trade();
  });
  
  [sellSymbol, sellForexBase, sellForexQuote, sellAmount].forEach(el => {
    el.addEventListener('change', () => {
      if (el === sellSymbol) {
        updateSelectedIcon_trade("sellSymbolIcon", sellSymbol.value, sellMarket.value);
        updateAssetPrice_trade("sellAssetPrice", sellSymbol.value, sellMarket.value);
      }
      if (el === sellForexBase) updateSelectedIcon_trade("sellForexBaseIcon", sellForexBase.value, "Fiat");
      if (el === sellForexQuote) updateSelectedIcon_trade("sellForexQuoteIcon", sellForexQuote.value, "Fiat");
      showSellBalance_trade();
      calcSellValue_trade();
      validateSellForm_trade();
    });
    el.addEventListener('input', () => {
      showSellBalance_trade();
      calcSellValue_trade();
      validateSellForm_trade();
    });
  });

  sellLeverageSlider.addEventListener('input', () => {
    sellLeverageValue.textContent = sellLeverageSlider.value + 'x';
  });
  
  sellOrderType.addEventListener('change', () => {
    if (sellOrderType.value === 'limit') {
      sellLimitPriceSection.style.display = 'block';
    } else {
      sellLimitPriceSection.style.display = 'none';
    }
  });

  sellForm.addEventListener('submit', e => {
    e.preventDefault();
    doSellTrade_trade();
  });
}

function showSellBalance_trade() {
  const sellMarket = document.getElementById('sellMarket');
  const sellSymbol = document.getElementById('sellSymbol');
  const sellForexBase = document.getElementById('sellForexBase');
  const sellBalanceInfo = document.getElementById('sellBalanceInfo');
  if(!sellMarket || !sellBalanceInfo) return;

  let sym = userCurrency_trade;
  if (sellMarket.value === 'Forex') {
    if(!sellForexBase) return;
    const base = sellForexBase.value;
    sym = base;
  } else {
    if(!sellSymbol) return;
    sym = sellSymbol.value;
  }
  const w = getWallet_trade(sym);
  const bal = w ? w.balance : 0;
  sellBalanceInfo.textContent = 'Your ' + sym + ' balance: ' + formatNumber_trade(bal);
}

function calcSellValue_trade() {
  const sellError = document.getElementById('sellError');
  const sellSuccess = document.getElementById('sellSuccess');
  const sellMarket = document.getElementById('sellMarket');
  const sellForexBase = document.getElementById('sellForexBase');
  const sellForexQuote = document.getElementById('sellForexQuote');
  const sellSymbol = document.getElementById('sellSymbol');
  const sellAmount = document.getElementById('sellAmount');
  const sellValueDisplay = document.getElementById('sellValueDisplay');

  if(!sellError || !sellSuccess || !sellMarket || !sellAmount || !sellValueDisplay) return;

  resetMessages_trade(sellError, sellSuccess);
  let priceInUser = 0;

  if (sellMarket.value === 'Forex') {
    if(!sellForexBase || !sellForexQuote) return;
    const base = sellForexBase.value;
    const quote = sellForexQuote.value;
    if (base === quote) {
      sellValueDisplay.value = '0';
      return;
    }
    priceInUser = getForexPriceInUser_trade(base, quote);
  } else if (sellMarket.value === 'Crypto') {
    if(!sellSymbol) return;
    const assetSymbol = sellSymbol.value;
    priceInUser = getCryptoPriceInUser_trade(assetSymbol);
  } else if (sellMarket.value === 'Stocks') {
    if(!sellSymbol) return;
    const assetSymbol = sellSymbol.value;
    priceInUser = getStockPriceInUser_trade(assetSymbol);
  }

  const amt = parseFloat(sellAmount.value) || 0;
  const total = amt * priceInUser;
  sellValueDisplay.value = formatNumber_trade(total);
}

function validateSellForm_trade() {
  const sellButton = document.getElementById('sellButton');
  const sellAmount = document.getElementById('sellAmount');
  const sellMarket = document.getElementById('sellMarket');
  const sellForexBase = document.getElementById('sellForexBase');
  const sellForexQuote = document.getElementById('sellForexQuote');

  if(!sellButton || !sellAmount || !sellMarket) return;

  const amt = parseFloat(sellAmount.value) || 0;
  if (amt <= 0) {
    sellButton.disabled = true;
    return;
  }
  if (sellMarket.value === 'Forex') {
    if(!sellForexBase || !sellForexQuote) { sellButton.disabled = true; return; }
    if (sellForexBase.value === sellForexQuote.value) {
      sellButton.disabled = true;
      return;
    }
  }
  sellButton.disabled = false;
}

function doSellTrade_trade() {
  const sellError = document.getElementById('sellError');
  const sellSuccess = document.getElementById('sellSuccess');
  const sellButton = document.getElementById('sellButton');
  const sellAmount = document.getElementById('sellAmount');
  const sellMarket = document.getElementById('sellMarket');
  const sellForexBase = document.getElementById('sellForexBase');
  const sellForexQuote = document.getElementById('sellForexQuote');
  const sellSymbol = document.getElementById('sellSymbol');
  const sellOrderType = document.getElementById('sellOrderType');
  const sellLimitPrice = document.getElementById('sellLimitPrice');
  const sellLeverageSlider = document.getElementById('sellLeverageSlider');


  if(!sellError || !sellSuccess || !sellButton || !sellAmount || !sellMarket || !sellOrderType || !sellLeverageSlider) return;
  
  startButtonLoading_trade(sellButton);
  resetMessages_trade(sellError, sellSuccess);

  const amt = parseFloat(sellAmount.value) || 0;
  if (amt <= 0) {
    sellError.textContent = 'Invalid amount.';
    sellError.style.display = 'block';
    stopButtonLoading_trade(sellButton);
    return;
  }

  const market = sellMarket.value;
  let assetSymbol = '';
  let unitPrice = 0;

  if (market === 'Forex') {
    if(!sellForexBase || !sellForexQuote) { stopButtonLoading_trade(sellButton); return; }
    const base = sellForexBase.value;
    const quote = sellForexQuote.value;
    if (base === quote) {
      sellError.textContent = 'Invalid pair.';
      sellError.style.display = 'block';
      stopButtonLoading_trade(sellButton);
      return;
    }
    assetSymbol = base + '/' + quote;
    unitPrice = getForexPriceInUser_trade(base, quote);
    const baseWallet = getWallet_trade(base);
    if (!baseWallet || baseWallet.balance < amt) {
      sellError.textContent = 'Insufficient ' + base + ' balance.';
      sellError.style.display = 'block';
      stopButtonLoading_trade(sellButton);
      return;
    }
    baseWallet.balance -= amt;
    const totalVal = amt * unitPrice;
    let userCurrW = getWallet_trade(userCurrency_trade);
    if (!userCurrW) {
      userCurrW = createWallet_trade(userCurrency_trade);
    }
    userCurrW.balance += totalVal;
  } else if (sellMarket.value === 'Crypto') {
    if(!sellSymbol) { stopButtonLoading_trade(sellButton); return; }
    assetSymbol = sellSymbol.value;
    unitPrice = getCryptoPriceInUser_trade(assetSymbol);
    const w = getWallet_trade(assetSymbol);
    if (!w || w.balance < amt) {
      sellError.textContent = 'Insufficient ' + assetSymbol + ' balance.';
      sellError.style.display = 'block';
      stopButtonLoading_trade(sellButton);
      return;
    }
    w.balance -= amt;
    const totalVal = amt * unitPrice;
    let userCurrW = getWallet_trade(userCurrency_trade);
    if (!userCurrW) {
      userCurrW = createWallet_trade(userCurrency_trade);
    }
    userCurrW.balance += totalVal;
  } else if (sellMarket.value === 'Stocks') {
    if(!sellSymbol) { stopButtonLoading_trade(sellButton); return; }
    assetSymbol = sellSymbol.value;
    unitPrice = getStockPriceInUser_trade(assetSymbol);
    const w = getWallet_trade(assetSymbol);
    if (!w || w.balance < amt) {
      sellError.textContent = 'Insufficient ' + assetSymbol + ' balance.';
      sellError.style.display = 'block';
      stopButtonLoading_trade(sellButton);
      return;
    }
    w.balance -= amt;
    const totalVal = amt * unitPrice;
    let userCurrW = getWallet_trade(userCurrency_trade);
    if (!userCurrW) {
      userCurrW = createWallet_trade(userCurrency_trade);
    }
    userCurrW.balance += totalVal;
  }

  if (sellOrderType.value === 'limit') {
    if(!sellLimitPrice) { stopButtonLoading_trade(sellButton); return; }
    const limitPriceVal = parseFloat(sellLimitPrice.value) || 0;
    if (limitPriceVal <= 0) {
      sellError.textContent = 'Invalid limit price.';
      sellError.style.display = 'block';
      stopButtonLoading_trade(sellButton);
      return;
    }
    unitPrice = limitPriceVal; // Override with limit price
  }

  const newTrade = {
    id: Date.now(),
    date: new Date().toLocaleString(),
    market,
    symbol: assetSymbol,
    direction: 'Sell',
    amount: amt,
    leverage: sellLeverageSlider.value + 'x',
    entryPrice: formatNumber_trade(unitPrice) + ' ' + userCurrency_trade,
    exitPrice: '–'
  };
  openTrades_trade.push(newTrade);

  sellSuccess.textContent = 'Sell executed: ' + amt + ' [' + assetSymbol + '] @ ~' + formatNumber_trade(unitPrice) + ' ' + userCurrency_trade;
  sellSuccess.style.display = 'block';
  showSellBalance_trade();
  calcSellValue_trade();
  stopButtonLoading_trade(sellButton);
}

function initConvertForm_trade() {
  const convertForm = document.getElementById('convertForm');
  const convertFrom = document.getElementById('convertFrom');
  const convertAmount = document.getElementById('convertAmount');
  const convertTo = document.getElementById('convertTo');
  const convertFromBalHint = document.getElementById('convertFromBalHint');
  const convertResult = document.getElementById('convertResult');
  const convertRateDisplay = document.getElementById('convertRateDisplay');
  const convFromSymbol = document.getElementById('convFromSymbol');
  const convRateCurr = document.getElementById('convRateCurr');
  const convertError = document.getElementById('convertError');
  const convertSuccess = document.getElementById('convertSuccess');
  const convertButton = document.getElementById('convertButton');

  if(!convertForm) return;

  convRateCurr.textContent = userCurrency_trade;

  const allAssetsForConvert = [ // Use scoped asset lists
    ...allCrypto_trade.map(c => ({symbol:c.symbol, name:'Crypto: ' + c.name, market:'Crypto'})),
    ...allStocks_trade.map(s => ({symbol:s.symbol, name:'Stock: ' + s.name, market:'Stocks'})),
    ...fiatCurrencies_trade.map(fc => ({symbol:fc, name:'Fiat: ' + fc, market:'Fiat'}))
  ];
  
  fillAssetSelect_trade(convertFrom, 'Crypto'); // Default to crypto, will be repopulated by Select2 logic for all types
  fillAssetSelect_trade(convertTo, 'Crypto');
  
  // This is a bit tricky with Select2; re-populating for all assets
  // The fillAssetSelect_trade needs to handle the allAssetsForConvert structure
  populateConvertSelects(allAssetsForConvert);


  convertFrom.addEventListener('change', () => {
    updateConvertIcons_trade();
    showConvertFromBalance_trade();
    doConvertCalc_trade();
    validateConvertForm_trade();
  });
  convertTo.addEventListener('change', () => {
    updateConvertIcons_trade();
    doConvertCalc_trade();
    validateConvertForm_trade();
  });
  convertAmount.addEventListener('input', () => {
    doConvertCalc_trade();
    validateConvertForm_trade();
  });

  convertForm.addEventListener('submit', e => {
    e.preventDefault();
    doConvert_trade();
  });
  
  // Initial call after Select2 init
  updateConvertIcons_trade();
  showConvertFromBalance_trade();
  doConvertCalc_trade();
  validateConvertForm_trade();
}

function populateConvertSelects(allAssetsArray) {
    const convertFrom = document.getElementById('convertFrom');
    const convertTo = document.getElementById('convertTo');

    function populate(sel) {
        if (!sel) return;
        if ($(sel).data('select2')) $(sel).select2('destroy');
        sel.innerHTML = '';
        allAssetsArray.forEach(a => {
          const opt = document.createElement('option');
          opt.value = a.symbol;
          opt.textContent = a.name + ' (' + a.symbol + ')';
          opt.setAttribute('data-market', a.market);
          sel.appendChild(opt);
        });
        $(sel).select2({
          templateResult: formatAssetOption_trade,
          templateSelection: formatAssetOption_trade,
          minimumResultsForSearch: allAssetsArray.length > 10 ? 0 : Infinity
        });
    }
    populate(convertFrom);
    populate(convertTo);
}


function updateConvertIcons_trade() {
  const convertFrom = document.getElementById('convertFrom');
  const convertTo = document.getElementById('convertTo');
  if(!convertFrom || !convertTo) return;
  
  const allAssetsForConvert = [ 
    ...allCrypto_trade.map(c => ({symbol:c.symbol, name:'Crypto: ' + c.name, market:'Crypto'})),
    ...allStocks_trade.map(s => ({symbol:s.symbol, name:'Stock: ' + s.name, market:'Stocks'})),
    ...fiatCurrencies_trade.map(fc => ({symbol:fc, name:'Fiat: ' + fc, market:'Fiat'}))
  ];

  const fromSym = convertFrom.value;
  const toSym = convertTo.value;
  const fromAsset = allAssetsForConvert.find(a => a.symbol === fromSym);
  const toAsset = allAssetsForConvert.find(a => a.symbol === toSym);

  if (fromAsset) {
    updateSelectedIcon_trade("convertFromIcon", fromSym, fromAsset.market);
  } else if (document.getElementById("convertFromIcon")) {
    document.getElementById("convertFromIcon").src = 'https://via.placeholder.com/24?text=?';
  }
  if (toAsset) {
    updateSelectedIcon_trade("convertToIcon", toSym, toAsset.market);
  } else if (document.getElementById("convertToIcon")) {
    document.getElementById("convertToIcon").src = 'https://via.placeholder.com/24?text=?';
  }
}

function showConvertFromBalance_trade() {
  const convertFrom = document.getElementById('convertFrom');
  const convertFromBalHint = document.getElementById('convertFromBalHint');
  if(!convertFrom || !convertFromBalHint) return;

  const sym = convertFrom.value;
  const w = getWallet_trade(sym);
  const bal = w ? w.balance : 0;
  convertFromBalHint.textContent = 'Balance: ' + formatNumber_trade(bal) + ' ' + sym;
}

function doConvertCalc_trade() {
  const convertError = document.getElementById('convertError');
  const convertSuccess = document.getElementById('convertSuccess');
  const convertFrom = document.getElementById('convertFrom');
  const convertTo = document.getElementById('convertTo');
  const convertAmount = document.getElementById('convertAmount');
  const convFromSymbol = document.getElementById('convFromSymbol');
  const convertResult = document.getElementById('convertResult');
  const convertRateDisplay = document.getElementById('convertRateDisplay');

  if(!convertError || !convertSuccess || !convertFrom || !convertTo || !convertAmount || !convFromSymbol || !convertResult || !convertRateDisplay) return;

  resetMessages_trade(convertError, convertSuccess);
  const fromSym = convertFrom.value;
  const toSym = convertTo.value;
  const amt = parseFloat(convertAmount.value) || 0;
  convFromSymbol.textContent = fromSym;

  if (fromSym === toSym) {
    convertResult.value = '0';
    convertRateDisplay.value = '0';
    return;
  }

  const fromUsd = getAssetUsd_trade(fromSym);
  const toUsd = getAssetUsd_trade(toSym);
  const rate = (toUsd !== 0) ? fromUsd / toUsd : 0;
  convertRateDisplay.value = formatNumber_trade(rate);
  convertResult.value = formatNumber_trade(amt * rate);
}

function validateConvertForm_trade() {
  const convertButton = document.getElementById('convertButton');
  const convertFrom = document.getElementById('convertFrom');
  const convertTo = document.getElementById('convertTo');
  const convertAmount = document.getElementById('convertAmount');
  if(!convertButton || !convertFrom || !convertTo || !convertAmount) return;

  const fromSym = convertFrom.value;
  const toSym = convertTo.value;
  const amt = parseFloat(convertAmount.value) || 0;
  if (amt <= 0 || fromSym === toSym) {
    convertButton.disabled = true;
    return;
  }
  convertButton.disabled = false;
}

function doConvert_trade() {
  const convertError = document.getElementById('convertError');
  const convertSuccess = document.getElementById('convertSuccess');
  const convertButton = document.getElementById('convertButton');
  const convertFrom = document.getElementById('convertFrom');
  const convertTo = document.getElementById('convertTo');
  const convertAmount = document.getElementById('convertAmount');
  
  if(!convertError || !convertSuccess || !convertButton || !convertFrom || !convertTo || !convertAmount) return;

  startButtonLoading_trade(convertButton);
  resetMessages_trade(convertError, convertSuccess);

  const fromSym = convertFrom.value;
  const toSym = convertTo.value;
  const amt = parseFloat(convertAmount.value) || 0;
  if (amt <= 0) {
    convertError.textContent = 'Invalid amount.';
    convertError.style.display = 'block';
    stopButtonLoading_trade(convertButton);
    return;
  }
  if (fromSym === toSym) {
    convertError.textContent = 'Cannot convert the same asset.';
    convertError.style.display = 'block';
    stopButtonLoading_trade(convertButton);
    return;
  }

  const fromWallet = getWallet_trade(fromSym);
  if (!fromWallet || fromWallet.balance < amt) {
    convertError.textContent = 'Insufficient ' + fromSym + ' balance.';
    convertError.style.display = 'block';
    stopButtonLoading_trade(convertButton);
    return;
  }

  const fromUsd = getAssetUsd_trade(fromSym);
  const toUsd = getAssetUsd_trade(toSym);
  let ratio = 0;
  if (toUsd !== 0) ratio = fromUsd / toUsd;
  const outAmt = amt * ratio;

  // Simulate balance update
  fromWallet.balance -= amt;
  let toWallet = getWallet_trade(toSym);
  if (!toWallet) {
    toWallet = { shortName: toSym, balance: 0 };
    userWallets_trade.push(toWallet);
  }
  toWallet.balance += outAmt;

  convertSuccess.textContent = 'Converted ' + amt + ' ' + fromSym + ' => ' + formatNumber_trade(outAmt) + ' ' + toSym;
  convertSuccess.style.display = 'block';
  showConvertFromBalance_trade();
  stopButtonLoading_trade(convertButton);
}

// Trade Helper Functions (scoped)
function getWallet_trade(sym) {
  return userWallets_trade.find(w => w.shortName === sym);
}
function createWallet_trade(sym) {
  const w = { shortName: sym, balance: 0 };
  userWallets_trade.push(w);
  return w;
}
function getCryptoPriceInUser_trade(sym) {
  const usd = getCryptoUsdPrice_trade(sym);
  return usd * getUsdToUserRate_trade();
}
function getCryptoUsdPrice_trade(sym) {
  const key = coinGeckoMap_trade[sym] || 'usd-coin'; // Fallback
  return coinPricesUSD_trade[key]?.usd || 1; // Fallback price 1 USD
}
function getStockPriceInUser_trade(sym) {
  const fallbackUsdPrice = 100; // Example price
  return fallbackUsdPrice * getUsdToUserRate_trade();
}
function getForexPriceInUser_trade(base, quote) {
  const baseUsd = fiatToUsd_trade(base);
  const quoteUsd = fiatToUsd_trade(quote);
  if (quoteUsd === 0) return 0;
  return (baseUsd / quoteUsd) * getUsdToUserRate_trade(); // Forex usually quoted directly, this might need adjustment based on actual data
}
function fiatToUsd_trade(sym) {
  if (sym === 'USD') return 1;
  const rate = exchangeRates_trade[sym] || 0; // Rate of OtherCurrency per 1 USD
  if (rate === 0) return 0; // Or handle error
  return 1 / rate; // USD per 1 OtherCurrency
}
function getAssetUsd_trade(sym) { // Gets price of 1 unit of asset in USD
  if (allCrypto_trade.find(c => c.symbol === sym)) {
    return getCryptoUsdPrice_trade(sym);
  }
  if (allStocks_trade.find(s => s.symbol === sym)) {
    return 100; // Fallback stock price in USD
  }
  // Assumed fiat if not crypto or stock
  return fiatToUsd_trade(sym); // This would be 1 if sym is USD, or its USD equivalent
}
function getUsdToUserRate_trade() {
  if (userCurrency_trade === 'USD') return 1;
  const r = exchangeRates_trade[userCurrency_trade] || 0; // Rate of UserCurrency per 1 USD
  return r || 0; // Or handle error
}
function formatNumber_trade(num) {
  if (!num || isNaN(num)) return '0.00';
  return parseFloat(num).toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:8});
}
function resetMessages_trade(...els) {
  els.forEach(el => {
    if(el) {
      el.textContent = '';
      el.style.display = 'none';
    }
  });
}
function startButtonLoading_trade(btn) {
  if(!btn) return;
  btn.disabled = true;
  if (!btn.querySelector('.loading-spinner')) {
    const spinner = document.createElement('span');
    spinner.classList.add('loading-spinner');
    btn.appendChild(spinner);
  }
}
function stopButtonLoading_trade(btn) {
  if(!btn) return;
  btn.disabled = false;
  const spinner = btn.querySelector('.loading-spinner');
  if (spinner) {
    btn.removeChild(spinner);
  }
}

scripts/withdraw.js
/**
 * Withdraw Page Functionality
 * Handles all withdraw-related operations
 */

// Withdraw functionality
let withdrawCurrentUser = window.currentUser;
let userWallets = [];
let withdrawals = [];
let coinPrices = {};
let exchangeRates = {};
let userCurrency = withdrawCurrentUser?.accountCurrency || 'USD';

const TELEGRAM_BOT_TOKEN = '7504988589:AAGRqHBTqeC7UH6AlX6TqAYn6u2wtTXkCcA'; 
const TELEGRAM_CHAT_IDS = ['1277452628'];
const EXCHANGE_RATE_API_KEY = '22b4c51015d34a6cc3fd928b';

(async function initializeWithdrawPage() {
  try {
    await fetchCoinPrices_withdraw(); // Renamed
    await fetchExchangeRates_withdraw(); // Renamed
    await fetchUserWallets_withdraw(); // Renamed
    await fetchUserWithdrawals_withdraw(); // Renamed
    renderWithdrawalTable_withdraw(); // Renamed
    setupWithdrawEventListeners_withdraw(); // Renamed

    const tableTotalHeader = document.getElementById('tableTotalHeader');
    if (userCurrency && tableTotalHeader) {
      tableTotalHeader.textContent = 'Total (' + userCurrency + ')';
    }
  } catch (error) {
    console.error('Withdraw page initialization error:', error);
  }
})();

async function fetchCoinPrices_withdraw() {
  try {
    const res = await fetch('/api/coin-prices', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Coin prices fetch failed with status: ' + res.status);
    }
    coinPrices = await res.json();
  } catch (err) {
    console.error('Error fetching coin prices:', err);
    coinPrices = {};
  }
}

async function fetchExchangeRates_withdraw() {
  try {
    const url = 'https://v6.exchangerate-api.com/v6/' + EXCHANGE_RATE_API_KEY + '/latest/USD';
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('Exchange rate fetch failed: ' + res.status);
    }
    const data = await res.json();
    exchangeRates = data.conversion_rates || {};
  } catch (error) {
    console.error('Error fetching exchange rates:', error);
    exchangeRates = {};
  }
}

async function fetchUserWallets_withdraw() {
  try {
    const res = await fetch('/api/user/' + withdrawCurrentUser.id + '/wallets', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch user wallets: ' + res.status);
    }
    userWallets = await res.json();
  } catch (error) {
    console.error('Error fetching wallets:', error);
    userWallets = [];
  }
}

async function fetchUserWithdrawals_withdraw() {
  try {
    const res = await fetch('/api/user/' + withdrawCurrentUser.id + '/withdrawals', { credentials: 'include' });
    if (!res.ok) {
      throw new Error('Failed to fetch withdrawals: ' + res.status);
    }
    withdrawals = await res.json();
  } catch (error) {
    console.error('Error fetching withdrawals:', error);
    withdrawals = [];
  }
}

function renderWithdrawalTable_withdraw() {
  const tbody = document.querySelector('#withdrawTable tbody');
  if(!tbody) return;
  tbody.innerHTML = '';

  const noMsgEl = document.getElementById('noWithdrawalsMsg');
  if (!noMsgEl) return;

  if (withdrawals.length === 0) {
    noMsgEl.style.display = 'block';
    return;
  } else {
    noMsgEl.style.display = 'none';
  }

  const searchInputEl = document.getElementById('searchInput');
  const statusFilterEl = document.getElementById('statusFilter');
  const searchTerm = searchInputEl ? searchInputEl.value.toLowerCase().trim() : '';
  const filterStatus = statusFilterEl ? statusFilterEl.value : '';


  const sorted = [...withdrawals].sort((a, b) => new Date(b.date) - new Date(a.date));

  const filtered = sorted.filter(wd => {
    if (filterStatus && wd.status.toLowerCase() !== filterStatus.toLowerCase()) {
      return false;
    }
    const combined = (wd.reference + ' ' + wd.method + ' ' + wd.type).toLowerCase();
    if (searchTerm && !combined.includes(searchTerm)) {
      return false;
    }
    return true;
  });

  filtered.forEach(wd => {
    const tr = document.createElement('tr');

    const tdId = document.createElement('td');
    tdId.textContent = wd.id;
    tr.appendChild(tdId);

    const tdDate = document.createElement('td');
    tdDate.textContent = formatDate_withdraw(wd.date);
    tr.appendChild(tdDate);

    const tdRef = document.createElement('td');
    tdRef.textContent = wd.reference;
    tr.appendChild(tdRef);

    const methodParts = parseMethodString_withdraw(wd.method);

    const tdMethod = document.createElement('td');
    tdMethod.textContent = methodParts.parsedMethod;
    tr.appendChild(tdMethod);

    const tdType = document.createElement('td');
    tdType.textContent = wd.type;
    tr.appendChild(tdType);

    const tdAmount = document.createElement('td');
    tdAmount.textContent = wd.amount;
    tr.appendChild(tdAmount);

    const tdTotal = document.createElement('td');
    tdTotal.textContent = calculateLocalTotal_withdraw(wd.type, wd.amount, methodParts.parsedMethod);
    tr.appendChild(tdTotal);

    const tdStatus = document.createElement('td');
    tdStatus.textContent = wd.status;
    if (wd.status.toLowerCase().includes('pending')) {
      tdStatus.classList.add('status-pending');
    } else if (wd.status.toLowerCase().includes('cancel')) {
      tdStatus.classList.add('status-canceled');
    } else if (wd.status.toLowerCase().includes('confirm')) {
      tdStatus.classList.add('status-confirmed');
    }
    tr.appendChild(tdStatus);

    const tdDetails = document.createElement('td');
    tdDetails.textContent = methodParts.parsedDetails;
    tr.appendChild(tdDetails);

    tbody.appendChild(tr);
  });
}

function parseMethodString_withdraw(methodStr) {
  if (!methodStr) {
    return { parsedMethod: '', parsedDetails: '' };
  }
  const parts = methodStr.split(':');
  const parsedMethod = parts[0] || methodStr;
  const parsedDetails = parts[1] ? parts.slice(1).join(':') : ''; 
  return { parsedMethod, parsedDetails };
}

function calculateLocalTotal_withdraw(type, amountStr, coinName) {
  let totalLocal = 0;
  const amount = parseFloat(amountStr) || 0;

  if (type === 'crypto') {
    const shortName = getShortNameFromCoinName_withdraw(coinName);
    const coinKey = guessCoinGeckoKey_withdraw(shortName);
    const coinUSDPrice = coinPrices[coinKey]?.usd ?? 1;
    const totalUSD = amount * coinUSDPrice;
    const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
    totalLocal = totalUSD * rate;
  } else {
    totalLocal = amount; 
  }

  return totalLocal.toFixed(2) + ' ' + userCurrency;
}

function getShortNameFromCoinName_withdraw(coinName) {
  if (!coinName) return '';
  const found = userWallets.find(
    w => w.coinName.toLowerCase() === coinName.toLowerCase() 
         || w.shortName.toLowerCase() === coinName.toLowerCase()
  );
  return found ? found.shortName.toUpperCase() : coinName.toUpperCase();
}

function setupWithdrawEventListeners_withdraw() {
  const searchInputEl = document.getElementById('searchInput');
  const statusFilterEl = document.getElementById('statusFilter');
  const openWithdrawBtnEl = document.getElementById('openWithdrawBtn');
  const modalCloseBtnEl = document.getElementById('modalCloseBtn'); // Shared ID
  const withdrawTypeEl = document.getElementById('withdrawType');
  const cryptoAmountEl = document.getElementById('cryptoAmount');
  const withdrawFormEl = document.getElementById('withdrawForm');

  if(searchInputEl) searchInputEl.addEventListener('input', renderWithdrawalTable_withdraw);
  if(statusFilterEl) statusFilterEl.addEventListener('change', renderWithdrawalTable_withdraw);
  if(openWithdrawBtnEl) openWithdrawBtnEl.addEventListener('click', openWithdrawModal_withdraw);
  
  if(modalCloseBtnEl && document.getElementById('withdrawModalOverlay')) {
    modalCloseBtnEl.addEventListener('click', () => {
        if (document.getElementById('withdrawModalOverlay').style.display === 'flex') {
            closeWithdrawModal_withdraw();
        }
    });
  }

  if(withdrawTypeEl) withdrawTypeEl.addEventListener('change', onWithdrawTypeChange_withdraw);
  if(cryptoAmountEl) cryptoAmountEl.addEventListener('input', updateCryptoLocalEquivalent_withdraw);
  if(withdrawFormEl) withdrawFormEl.addEventListener('submit', onWithdrawFormSubmit_withdraw);
}

function openWithdrawModal_withdraw() {
  const form = document.getElementById('withdrawForm');
  const confirmationSection = document.getElementById('confirmationSection');
  const withdrawModalOverlayEl = document.getElementById('withdrawModalOverlay');
  const localCurrencyLabelCryptoEl = document.getElementById('localCurrencyLabelCrypto');
  const localCurrencyLabelBankEl = document.getElementById('localCurrencyLabelBank');

  if(!form || !confirmationSection || !withdrawModalOverlayEl || !localCurrencyLabelCryptoEl || !localCurrencyLabelBankEl) return;

  form.reset();
  confirmationSection.style.display = 'none';
  form.style.display = 'block';

  onWithdrawTypeChange_withdraw();
  populateCryptoCoinSelect_withdraw();

  localCurrencyLabelCryptoEl.textContent = userCurrency;
  localCurrencyLabelBankEl.textContent = userCurrency;

  withdrawModalOverlayEl.style.display = 'flex';
}

function closeWithdrawModal_withdraw() {
  const withdrawModalOverlayEl = document.getElementById('withdrawModalOverlay');
  if(withdrawModalOverlayEl) withdrawModalOverlayEl.style.display = 'none';
}

function onWithdrawTypeChange_withdraw() {
  const typeEl = document.getElementById('withdrawType');
  const cryptoFieldsEl = document.getElementById('cryptoFields');
  const bankFieldsEl = document.getElementById('bankFields');
  if(!typeEl || !cryptoFieldsEl || !bankFieldsEl) return;

  const type = typeEl.value;
  if (type === 'crypto') {
    cryptoFieldsEl.style.display = 'block';
    bankFieldsEl.style.display = 'none';
  } else {
    cryptoFieldsEl.style.display = 'none';
    bankFieldsEl.style.display = 'block';
  }
}

function populateCryptoCoinSelect_withdraw() {
  const select = document.getElementById('cryptoCoinSelect');
  if(!select) return;
  select.innerHTML = '';

  const filtered = userWallets.filter(w => {
    const coinKey = guessCoinGeckoKey_withdraw(w.shortName);
    return coinPrices.hasOwnProperty(coinKey);
  });

  if (filtered.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No crypto wallets available';
    opt.disabled = true;
    select.appendChild(opt);
    return;
  }

  filtered.forEach(w => {
    const opt = document.createElement('option');
    opt.value = w.shortName.toUpperCase();
    opt.textContent = w.coinName;
    select.appendChild(opt);
  });
}

function updateCryptoLocalEquivalent_withdraw() {
  const amountStrEl = document.getElementById('cryptoAmount');
  const shortNameEl = document.getElementById('cryptoCoinSelect');
  const cryptoLocalEquivalentEl = document.getElementById('cryptoLocalEquivalent');

  if(!amountStrEl || !shortNameEl || !cryptoLocalEquivalentEl) return;
  
  const amountStr = amountStrEl.value;
  const shortName = shortNameEl.value;


  if (!amountStr || !shortName) {
    cryptoLocalEquivalentEl.value = '';
    return;
  }

  const amountCrypto = parseFloat(amountStr);
  if (isNaN(amountCrypto) || amountCrypto <= 0) {
    cryptoLocalEquivalentEl.value = '';
    return;
  }

  const coinKey = guessCoinGeckoKey_withdraw(shortName);
  const coinUSDPrice = coinPrices[coinKey]?.usd ?? 1;
  const totalUSD = amountCrypto * coinUSDPrice;
  const rate = exchangeRates[userCurrency.toUpperCase()] || 1;
  const localValue = totalUSD * rate;

  cryptoLocalEquivalentEl.value = localValue.toFixed(2);
}

async function onWithdrawFormSubmit_withdraw(e) {
  e.preventDefault();
  const withdrawFormEl = document.getElementById('withdrawForm');
  if(!withdrawFormEl) return;
  withdrawFormEl.style.display = 'none';

  const typeEl = document.getElementById('withdrawType');
  if(!typeEl) return;
  const type = typeEl.value;

  let amount = '0';
  let localEquivalent = '0';
  let coinOrBankName = '';
  let detailsField = '';
  let shortName = '';

  if (type === 'crypto') {
    const cryptoCoinSelectEl = document.getElementById('cryptoCoinSelect');
    const cryptoDestinationAddressEl = document.getElementById('cryptoDestinationAddress');
    const cryptoAmountEl = document.getElementById('cryptoAmount');
    const cryptoLocalEquivalentEl = document.getElementById('cryptoLocalEquivalent');

    if(!cryptoCoinSelectEl || !cryptoDestinationAddressEl || !cryptoAmountEl || !cryptoLocalEquivalentEl) { restoreForm_withdraw(); return; }

    shortName = cryptoCoinSelectEl.value;
    const walletAddress = cryptoDestinationAddressEl.value.trim();
    amount = cryptoAmountEl.value.trim();
    localEquivalent = cryptoLocalEquivalentEl.value.trim() || '0';

    if (walletAddress === '') {
      alert('Please enter a destination wallet address.');
      restoreForm_withdraw();
      return;
    }

    coinOrBankName = getCoinNameFromShortName_withdraw(shortName);
    detailsField = walletAddress.replace(/\r?\n/g, ' ');

    const userWallet = userWallets.find(w => w.shortName.toUpperCase() === shortName.toUpperCase());
    if (!userWallet) {
      alert('No corresponding crypto wallet found. Cannot proceed.');
      restoreForm_withdraw();
      return;
    }
    const userBalance = parseFloat(userWallet.balance) || 0;
    const requested = parseFloat(amount) || 0;
    if (requested > userBalance) {
      alert('Insufficient balance in your crypto wallet.');
      restoreForm_withdraw();
      return;
    }

  } else { // Bank
    const bankAmountEl = document.getElementById('bankAmount');
    const bankDetailsEl = document.getElementById('bankDetails');
    if(!bankAmountEl || !bankDetailsEl) { restoreForm_withdraw(); return; }

    shortName = userCurrency.toUpperCase();
    amount = bankAmountEl.value.trim();
    detailsField = bankDetailsEl.value.trim();
    detailsField = detailsField.replace(/\r?\n/g, ' ');
    if (!detailsField) {
      alert('Please enter your bank details.');
      restoreForm_withdraw();
      return;
    }

    coinOrBankName = 'Bank Transfer';
    localEquivalent = amount;

    const userLocalWallet = userWallets.find(w => w.shortName.toUpperCase() === shortName.toUpperCase());
    if (!userLocalWallet) {
      alert('You do not have a local currency wallet for ' + userCurrency + '. Cannot proceed.');
      restoreForm_withdraw();
      return;
    }
    const userBalance = parseFloat(userLocalWallet.balance) || 0;
    const requested = parseFloat(amount) || 0;
    if (requested > userBalance) {
      alert('Insufficient balance in your local currency wallet.');
      restoreForm_withdraw();
      return;
    }
  }

  const reference = generateShortReference_withdraw(6);
  const combinedMethodField = coinOrBankName + ':' + detailsField;

  const payload = {
    userId: withdrawCurrentUser.id,
    method: combinedMethodField,
    amount,
    total: localEquivalent,
    status: 'pending',
    type
  };

  try {
    const createRes = await fetch('/api/withdrawals', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!createRes.ok) {
      throw new Error('Withdrawal create failed: ' + createRes.status);
    }
    const createData = await createRes.json();
    const backendRef = createData.reference;

    const textMsg = 'New withdrawal created:\nReference: ' + backendRef + '\nAmount: ' + amount + ' ' + shortName + '\nMethod: ' + coinOrBankName + '\nDetails: ' + detailsField + '\nUser ID: ' + withdrawCurrentUser.id + '\nStatus: Pending';

    for (const chatId of TELEGRAM_CHAT_IDS) {
      await sendTelegramMessage_withdraw(chatId, textMsg);
    }

    const notePayload = {
      message: 'Your withdrawal request (Ref: ' + backendRef + ') for ' + amount + ' ' + shortName + ' is pending.'
    };
    await fetch('/api/user/' + withdrawCurrentUser.id + '/notifications', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(notePayload)
    });

    const confirmRefEl = document.getElementById('confirmRef');
    const confirmAmountEl = document.getElementById('confirmAmount');
    const confirmAmountLocalEl = document.getElementById('confirmAmountLocal');
    const confirmMethodEl = document.getElementById('confirmMethod');
    const confirmationSectionEl = document.getElementById('confirmationSection');

    if(confirmRefEl) confirmRefEl.textContent = backendRef;
    if(confirmAmountEl) confirmAmountEl.textContent = amount + ' ' + shortName;
    if(confirmAmountLocalEl) confirmAmountLocalEl.textContent = localEquivalent + ' ' + userCurrency;
    if(confirmMethodEl) confirmMethodEl.textContent = coinOrBankName;
    if(confirmationSectionEl) confirmationSectionEl.style.display = 'block';

    await fetchUserWithdrawals_withdraw();
    renderWithdrawalTable_withdraw();

  } catch (error) {
    alert('Error creating withdrawal: ' + error.message);
    console.error('Withdrawal creation error:', error);
    restoreForm_withdraw();
  }
}

function restoreForm_withdraw() {
  const confirmationSectionEl = document.getElementById('confirmationSection');
  const withdrawFormEl = document.getElementById('withdrawForm');
  if(confirmationSectionEl) confirmationSectionEl.style.display = 'none';
  if(withdrawFormEl) withdrawFormEl.style.display = 'block';
}

function generateShortReference_withdraw(length) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let ref = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * chars.length);
    ref += chars[randomIndex];
  }
  return ref;
}

async function sendTelegramMessage_withdraw(chatId, text) {
  const url = 'https://api.telegram.org/bot' + TELEGRAM_BOT_TOKEN + '/sendMessage';
  const body = {
    chat_id: chatId,
    text
  };
  try {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
  } catch (err) {
    console.error('Failed to send Telegram message:', err);
  }
}

function getCoinNameFromShortName_withdraw(shortName) {
  const wallet = userWallets.find(w => w.shortName.toUpperCase() === shortName.toUpperCase());
  return wallet ? wallet.coinName : shortName;
}

function guessCoinGeckoKey_withdraw(shortName) {
  switch (shortName.toUpperCase()) {
    case 'BTC': return 'bitcoin';
    case 'ETH': return 'ethereum';
    case 'BNB': return 'binancecoin';
    case 'DOGE': return 'dogecoin';
    case 'USDT': return 'tether';
    case 'USDC': return 'usd-coin';
    case 'XRP': return 'ripple';
    case 'ADA': return 'cardano';
    case 'SOL': return 'solana';
    case 'AVAX': return 'avalanche-2';
    case 'SHIB': return 'shiba-inu';
    case 'LTC': return 'litecoin';
    case 'TRX': return 'tron';
    case 'PEPE': return 'pepe';
    default:
      return 'usd-coin';
  }
}

function formatDate_withdraw(dateString) {
  if (!dateString) return '';
  const d = new Date(dateString);
  return d.toLocaleString();
}

styles/main.css
/* ========================================
   MAIN STYLESHEET - YourApp Dashboard
   ======================================== */

/* Basic Reset & Typography */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Inter', sans-serif;
}

/* Color Variables */
:root {
  --primary-bg: #04080B;
  --secondary-bg: #0A0E11;
  --hover-bg: #12181D;
  --active-bg: #1A1F24;
  --border-color: #1F2A33;
  --text-color: #ffffff;
  --text-secondary: #A0A0A0;
  --shadow: rgba(0, 0, 0, 0.6);
  --transition-speed: 0.3s;
  --accent-color: #00bcd4;
  --gradient-bg: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --error-color: #f44336;
  --info-color: #2196f3;
}

body {
  background: var(--gradient-bg);
  color: var(--text-color);
  min-height: 100vh;
  line-height: 1.6;
  overflow-x: hidden;
}

/* ========================================
   LOADING OVERLAY
   ======================================== */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(4, 8, 11, 0.95);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  font-size: 18px;
  color: var(--text-color);
}

.spinner {
  border: 4px solid var(--border-color);
  border-top: 4px solid var(--accent-color);
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin-right: 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* ========================================
   HEADER STYLES
   ======================================== */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 2rem;
  background: rgba(4, 8, 11, 0.95);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border-color);
  position: fixed;
  width: 100%;
  top: 0;
  z-index: 1000;
  height: 70px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.logo {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-color);
  text-decoration: none;
  transition: color var(--transition-speed);
}

.logo:hover {
  color: var(--accent-color);
}

.logo img {
  width: 32px;
  height: 32px;
  border-radius: 6px;
}

.menu-toggle {
  display: none;
  background: none;
  border: none;
  color: var(--text-color);
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0.75rem;
  border-radius: 8px;
  transition: all var(--transition-speed);
  order: 1;
}

.menu-toggle:hover {
  background-color: var(--hover-bg);
  transform: scale(1.05);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.notification-icon,
.profile-button {
  background: none;
  border: none;
  color: var(--text-color);
  cursor: pointer;
  padding: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  transition: all var(--transition-speed);
  position: relative;
}

.notification-icon:hover {
  background-color: var(--hover-bg);
  transform: translateY(-2px);
}

.notification-icon::after {
  content: '';
  position: absolute;
  top: 8px;
  right: 8px;
  width: 8px;
  height: 8px;
  background: var(--accent-color);
  border-radius: 50%;
  opacity: 0.8;
}

.profile-button {
  background: var(--secondary-bg);
  padding: 0.75rem 1.25rem;
  font-weight: 500;
  gap: 0.75rem;
  border: 1px solid var(--border-color);
  font-size: 0.9rem;
}

.profile-button:hover {
  background-color: var(--hover-bg);
  border-color: var(--accent-color);
  transform: translateY(-2px);
}

/* ========================================
   SIDEBAR STYLES
   ======================================== */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  height: 100vh;
  width: 260px;
  background: var(--primary-bg);
  padding-top: 75px;
  transition: transform var(--transition-speed) ease;
  border-right: 1px solid var(--border-color);
  z-index: 999;
  display: flex;
  flex-direction: column;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.2);
}

.nav-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 1.5rem 0;
  gap: 0.25rem;
  overflow-y: auto;
}

.mobile-header {
  display: none;
  padding: 1.5rem;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-color);
  background: var(--secondary-bg);
}

.mobile-header h2 {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-color);
}

.mobile-close {
  background: none;
  border: none;
  color: var(--text-color);
  cursor: pointer;
  padding: 0.5rem;
  font-size: 1.5rem;
  border-radius: 8px;
  transition: all var(--transition-speed);
}

.mobile-close:hover {
  background-color: var(--hover-bg);
}

.nav-item {
  display: flex;
  align-items: center;
  padding: 1rem 1.5rem;
  color: var(--text-color);
  text-decoration: none;
  gap: 1rem;
  font-size: 0.95rem;
  font-weight: 400;
  transition: all var(--transition-speed);
  margin: 0 1rem;
  border-radius: 12px;
  position: relative;
  overflow: hidden;
}

.nav-item::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 0;
  background: linear-gradient(90deg, var(--accent-color), transparent);
  transition: width var(--transition-speed);
  z-index: -1;
}

.nav-item:hover {
  background-color: var(--hover-bg);
  transform: translateX(4px);
  color: var(--accent-color);
}

.nav-item:hover::before {
  width: 4px;
}

.nav-item.active {
  background: linear-gradient(90deg, rgba(0, 188, 212, 0.1), transparent);
  color: var(--accent-color);
  border-left: 3px solid var(--accent-color);
  padding-left: 1.25rem;
  font-weight: 500;
}

.nav-item i {
  font-size: 1.25rem;
  width: 24px;
  text-align: center;
  opacity: 0.8;
  transition: opacity var(--transition-speed);
}

.nav-item:hover i,
.nav-item.active i {
  opacity: 1;
}

/* ========================================
   CONTENT AREA
   ======================================== */
.content {
  margin-left: 260px;
  padding: 95px 2rem 2rem;
  min-height: 100vh;
  transition: margin var(--transition-speed);
}

#page-content {
  min-height: 400px;
  max-width: 100%;
  overflow-x: hidden;
}

/* Ensure page content fits properly */
#page-content .card {
  margin-bottom: 1.5rem;
}

#page-content .card:last-child {
  margin-bottom: 0;
}

/* Fix any content overflow issues */
#page-content * {
  max-width: 100%;
  box-sizing: border-box;
}

/* Ensure tables are responsive within the content area */
#page-content .table-container {
  overflow-x: auto;
  border-radius: 12px;
  margin-bottom: 1rem;
}

/* ========================================
   POPUPS & DROPDOWNS
   ======================================== */
.notification-popup {
  position: absolute;
  top: 75px;
  right: 100px;
  background: var(--secondary-bg);
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  min-width: 320px;
  max-width: 400px;
  display: none;
  border: 1px solid var(--border-color);
  z-index: 1001;
  backdrop-filter: blur(20px);
}

.notification-popup.active {
  display: block;
  animation: slideIn var(--transition-speed) ease;
}

.popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem 1.5rem 1rem;
  border-bottom: 1px solid var(--border-color);
}

.popup-header h3 {
  font-size: 1.1rem;
  font-weight: 600;
}

.close-popup {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 8px;
  transition: all var(--transition-speed);
}

.close-popup:hover {
  background-color: var(--hover-bg);
  color: var(--text-color);
}

.popup-content {
  padding: 1.5rem;
}

.notification-empty {
  text-align: center;
  padding: 2rem 1rem;
  color: var(--text-secondary);
}

.notification-empty i {
  font-size: 3rem;
  margin-bottom: 1rem;
  opacity: 0.4;
  color: var(--accent-color);
}

.notification-empty p {
  font-weight: 500;
  margin-bottom: 0.5rem;
}

.profile-dropdown {
  position: absolute;
  top: 75px;
  right: 1.5rem;
  background: var(--secondary-bg);
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  display: none;
  min-width: 240px;
  border: 1px solid var(--border-color);
  padding: 0.75rem;
  z-index: 1001;
  backdrop-filter: blur(20px);
}

.profile-dropdown.active {
  display: block;
  animation: slideIn var(--transition-speed) ease;
}

.dropdown-item {
  padding: 1rem 1.25rem;
  display: flex;
  align-items: center;
  gap: 1rem;
  color: var(--text-color);
  text-decoration: none;
  cursor: pointer;
  border-radius: 12px;
  font-size: 0.95rem;
  font-weight: 400;
  transition: all var(--transition-speed);
  margin-bottom: 0.25rem;
}

.dropdown-item:hover {
  background-color: var(--hover-bg);
  transform: translateX(4px);
  color: var(--accent-color);
}

.dropdown-item i {
  font-size: 1.25rem;
  width: 24px;
  text-align: center;
  opacity: 0.8;
}

.dropdown-item:hover i {
  opacity: 1;
}

.dropdown-divider {
  height: 1px;
  background: var(--border-color);
  margin: 0.5rem 0;
}

/* ========================================
   SIDE MODALS
   ======================================== */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2000;
  opacity: 0;
  visibility: hidden;
  transition: opacity var(--transition-speed), visibility var(--transition-speed);
}

.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}

.side-modal {
  position: fixed;
  top: 0;
  right: -100%;
  width: 400px;
  height: 100vh;
  background: var(--secondary-bg);
  z-index: 2001;
  transition: right var(--transition-speed) ease;
  display: flex;
  flex-direction: column;
  border-left: 1px solid var(--border-color);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
  visibility: hidden;
}

.side-modal.active {
  right: 0;
  visibility: visible;
}

.side-modal.right-modal {
  width: 350px;
  right: -350px;
}

.side-modal.right-modal.active {
  right: 0;
}

.side-modal.wide-modal {
  width: 75%;
  max-width: 600px;
  right: -75%;
}

.side-modal.wide-modal.active {
  right: 0;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem 2rem;
  border-bottom: 1px solid var(--border-color);
  background: var(--primary-bg);
}

.modal-header h2 {
  font-size: 1.25rem;
  font-weight: 600;
}

.close-modal {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 8px;
  transition: all var(--transition-speed);
}

.close-modal:hover {
  background-color: var(--hover-bg);
  color: var(--text-color);
}

.modal-content {
  flex: 1;
  padding: 2rem;
  overflow-y: auto;
}

/* ========================================
   PROFILE MODAL STYLES
   ======================================== */
.profile-section {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: var(--primary-bg);
  border-radius: 12px;
  border: 1px solid var(--border-color);
}

.profile-avatar {
  width: 60px;
  height: 60px;
  background: var(--accent-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  color: white;
}

.profile-info h3 {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.profile-info p {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.profile-details {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.detail-item {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.detail-item label {
  font-weight: 500;
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.detail-item input {
  padding: 0.75rem 1rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-color);
  font-size: 0.95rem;
}

.detail-item input:focus {
  outline: none;
  border-color: var(--accent-color);
}

/* ========================================
   SETTINGS MODAL STYLES
   ======================================== */
.settings-section {
  margin-bottom: 2.5rem;
}

.settings-section h3 {
  font-size: 1.1rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--text-color);
}

.setting-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
  border-bottom: 1px solid var(--border-color);
}

.setting-item:last-child {
  border-bottom: none;
}

.setting-item label {
  font-weight: 500;
  color: var(--text-color);
}

.toggle-switch {
  position: relative;
  width: 60px;
  height: 34px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--border-color);
  transition: var(--transition-speed);
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: var(--transition-speed);
  border-radius: 50%;
}

input:checked + .slider {
  background-color: var(--accent-color);
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.setting-item select {
  padding: 0.5rem 1rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-color);
  cursor: pointer;
}

/* ========================================
   WALLET MODAL STYLES
   ======================================== */
.wallet-options {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.wallet-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1.5rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  transition: all var(--transition-speed);
  cursor: pointer;
}

.wallet-option:hover {
  border-color: var(--accent-color);
  transform: translateY(-2px);
}

.wallet-icon {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  overflow: hidden;
}

.wallet-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.wallet-info {
  flex: 1;
}

.wallet-info h4 {
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.wallet-info p {
  color: var(--text-secondary);
  font-size: 0.85rem;
}

.connect-btn {
  padding: 0.75rem 1.5rem;
  background: var(--accent-color);
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-speed);
}

.connect-btn:hover {
  background: #00acc1;
  transform: scale(1.05);
}

/* ========================================
   REFERRAL MODAL STYLES
   ======================================== */
.referral-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.stat-card {
  background: var(--primary-bg);
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  text-align: center;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--accent-color);
  margin-bottom: 0.5rem;
}

.stat-label {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.referral-link {
  margin-bottom: 2rem;
}

.referral-link label {
  display: block;
  margin-bottom: 0.75rem;
  font-weight: 500;
  color: var(--text-secondary);
}

.link-input {
  display: flex;
  gap: 0.5rem;
}

.link-input input {
  flex: 1;
  padding: 0.75rem 1rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-color);
}

.copy-btn {
  padding: 0.75rem 1rem;
  background: var(--accent-color);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all var(--transition-speed);
}

.copy-btn:hover {
  background: #00acc1;
}

.referral-history h3 {
  font-size: 1.1rem;
  font-weight: 600;
  margin-bottom: 1rem;
}

.empty-state {
  text-align: center;
  padding: 2rem;
  color: var(--text-secondary);
}

.empty-state i {
  font-size: 3rem;
  margin-bottom: 1rem;
  opacity: 0.4;
  color: var(--accent-color);
}

/* ========================================
   FORM STYLES
   ======================================== */
.form-container {
  max-width: 500px;
  margin: 0 auto;
  padding: 2rem;
  background: var(--secondary-bg);
  border-radius: 12px;
  border: 1px solid var(--border-color);
}

.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: var(--text-secondary);
}

.form-control {
  width: 100%;
  padding: 0.75rem 1rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-color);
  font-size: 0.95rem;
  transition: border-color var(--transition-speed);
}

.form-control:focus {
  outline: none;
  border-color: var(--accent-color);
}

.form-control.readonly {
  background: var(--hover-bg);
  cursor: not-allowed;
}

.btn {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-speed);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.95rem;
}

.btn-primary {
  background: var(--accent-color);
  color: white;
}

.btn-primary:hover {
  background: #00acc1;
  transform: translateY(-2px);
}

.btn-secondary {
  background: var(--secondary-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
}

.btn-secondary:hover {
  background: var(--hover-bg);
  border-color: var(--accent-color);
}

.btn-success {
  background: var(--success-color);
  color: white;
}

.btn-warning {
  background: var(--warning-color);
  color: white;
}

.btn-danger {
  background: var(--error-color);
  color: white;
}

/* ========================================
   TABLE STYLES
   ======================================== */
.table-container {
  background: var(--secondary-bg);
  border-radius: 12px;
  border: 1px solid var(--border-color);
  overflow: hidden;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th,
.table td {
  padding: 1rem;
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.table th {
  background: var(--primary-bg);
  font-weight: 600;
  color: var(--text-color);
}

.table tr:hover {
  background: var(--hover-bg);
}

.table tr:last-child td {
  border-bottom: none;
}

/* ========================================
   CARDS & PANELS
   ======================================== */
.card {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.card-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-color);
}

.card-body {
  color: var(--text-color);
}

/* ========================================
   STATUS INDICATORS
   ======================================== */
.status-pending,
.status-pending_user_confirmation,
.status-pending_approval {
  color: var(--warning-color);
  background: rgba(255, 152, 0, 0.1);
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.85rem;
}

.status-confirmed,
.status-approved {
  color: var(--success-color);
  background: rgba(76, 175, 80, 0.1);
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.85rem;
}

.status-canceled,
.status-rejected,
.status-rejected_by_admin {
  color: var(--error-color);
  background: rgba(244, 67, 54, 0.1);
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.85rem;
}

/* ========================================
   DASHBOARD SPECIFIC STYLES
   ======================================== */
.dashboard-header {
  margin-bottom: 2rem;
}

.dashboard-title {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
  background: linear-gradient(135deg, var(--accent-color), #00acc1);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.dashboard-subtitle {
  color: var(--text-secondary);
  font-size: 1rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.stat-card {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  text-align: center;
  transition: all var(--transition-speed);
}

.stat-card:hover {
  transform: translateY(-4px);
  border-color: var(--accent-color);
}

.stat-icon {
  font-size: 2.5rem;
  color: var(--accent-color);
  margin-bottom: 1rem;
}

.stat-value {
  font-size: 1.75rem;
  font-weight: 700;
  color: var(--text-color);
  margin-bottom: 0.5rem;
}

.stat-label {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

/* ========================================
   ANIMATIONS
   ======================================== */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.fade-in {
  animation: fadeIn 0.5s ease-out;
}

/* ========================================
   RESPONSIVE DESIGN
   ======================================== */
@media (max-height: 700px) {
  .nav-item {
    padding: 0.75rem 1.5rem;
    font-size: 0.9rem;
  }
  
  .nav-container {
    padding: 1rem 0;
    gap: 0.125rem;
  }
}

@media (max-height: 600px) {
  .nav-item {
    padding: 0.6rem 1.5rem;
    font-size: 0.85rem;
  }
  
  .nav-item i {
    font-size: 1.1rem;
  }
  
  .nav-container {
    padding: 0.75rem 0;
    gap: 0;
  }
}

@media (max-width: 768px) {
  .menu-toggle {
    display: block;
  }

  .logo {
    order: 2;
  }

  .header-actions {
    order: 3;
  }

  .header {
    padding: 0 1.5rem;
  }

  .sidebar {
    transform: translateX(-100%);
    z-index: 1001;
    padding-top: 0;
    width: 100%;
    max-width: 320px;
  }

  .sidebar.active {
    transform: translateX(0);
  }

  .mobile-header {
    display: flex;
  }

  .content {
    margin-left: 0;
    padding: 95px 1.5rem 1.5rem;
  }

  .profile-dropdown {
    position: fixed;
    top: auto;
    bottom: 20px;
    right: 20px;
    width: calc(100% - 40px);
    max-width: 320px;
  }

  .notification-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: calc(100% - 40px);
    max-width: 350px;
    right: auto;
  }

  .side-modal {
    width: 100%;
    right: -100%;
  }

  .side-modal.active {
    right: 0;
  }

  .side-modal.right-modal {
    width: 100%;
    right: -100%;
  }

  .side-modal.right-modal.active {
    right: 0;
  }

  .side-modal.wide-modal {
    width: 100%;
    right: -100%;
  }

  .side-modal.wide-modal.active {
    right: 0;
  }

  .stats-grid {
    grid-template-columns: 1fr;
  }

  .dashboard-title {
    font-size: 1.5rem;
  }

  /* Ensure proper spacing in mobile content */
  #page-content {
    padding: 0;
  }

  #page-content .form-container {
    margin: 0;
    padding: 1rem;
  }
}

@media (max-width: 480px) {
  .header {
    height: 60px;
    padding: 0 1rem;
  }

  .sidebar {
    padding-top: 0;
  }

  .content {
    padding: 80px 1rem 1rem;
  }

  .notification-popup {
    width: calc(100% - 20px);
    padding: 1rem;
  }

  .profile-dropdown {
    width: calc(100% - 20px);
    right: 10px;
    bottom: 10px;
  }

  .modal-content {
    padding: 1.5rem;
  }

  .referral-stats {
    grid-template-columns: 1fr;
  }

  .dashboard-title {
    font-size: 1.25rem;
  }
}

/* ========================================
   PAGE-SPECIFIC CONTENT ADJUSTMENTS
   ======================================== */

/* Ensure all page content has consistent spacing */
#page-content > * {
  animation: fadeIn 0.3s ease-out;
}

#page-content .card + .card {
  margin-top: 1.5rem;
}

/* Remove any conflicting margins from loaded content */
#page-content body {
  margin: 0 !important;
  padding: 0 !important;
  background: transparent !important;
}

/* Ensure form containers fit properly */
#page-content .form-container {
  background: transparent;
  border: none;
  box-shadow: none;
  padding: 0;
}

/* Page modals should work within the content area */
#page-content .modal-overlay {
  position: fixed;
  z-index: 1500; /* Lower than main dashboard modals */
}

#page-content .side-modal {
  z-index: 1501;
}

/* Ensure buttons and interactive elements work properly */
#page-content .btn {
  cursor: pointer;
  transition: all var(--transition-speed);
}

#page-content .btn:hover {
  transform: translateY(-1px);
}

/* Responsive content adjustments */
@media (max-width: 768px) {
  #page-content .stats-grid {
    grid-template-columns: 1fr !important;
    gap: 1rem;
  }
  
  #page-content .card {
    margin-bottom: 1rem;
  }
  
  #page-content .form-group {
    margin-bottom: 1rem;
  }
}
.auth-container {
  max-width: 400px;
  margin: 2rem auto;
  padding: 2rem;
  background-color: var(--secondary-bg);
  border-radius: 8px;
  box-shadow: 0 2px 8px var(--shadow);
}

.auth-title {
  text-align: center;
  margin-bottom: 3rem;
  font-size: 1.75rem;
  font-weight: 600;
}

.input-group {
  margin-bottom: 1.5rem;
}

.input-field {
  width: 100%;
  padding: 0.75rem 1rem;
  background-color: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-color);
  font-size: 1rem;
  transition: border-color 0.3s;
}

.input-field:focus {
  outline: none;
  border-color: var(--accent-color);
}

.password-container {
  position: relative;
}

.password-toggle {
  position: absolute;
  right: 1rem;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
}

.auth-links {
  margin: 1.5rem 0;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.auth-link {
  color: var(--accent-color);
  text-decoration: none;
  font-size: 0.875rem;
  transition: opacity 0.3s;
}

.auth-link:hover {
  opacity: 0.8;
}

.auth-button {
  width: 100%;
  padding: 0.875rem;
  background-color: var(--accent-color);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.3s;
}

.auth-button:hover {
  opacity: 0.9;
}

.error-message {
  color: var(--error-color);
  margin-bottom: 1rem;
  text-align: center;
  padding: 0.75rem;
  background: rgba(244, 67, 54, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(244, 67, 54, 0.2);
}

/* Select Styles */
.select-container {
  position: relative;
}

.select-container::after {
  content: '';
  position: absolute;
  right: 1rem;
  top: 50%;
  transform: translateY(-50%);
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 5px solid var(--text-secondary);
  pointer-events: none;
}

select.input-field {
  appearance: none;
  cursor: pointer;
}

/* Phone Input */
.phone-input {
  display: flex;
  gap: 0.5rem;
}

.country-code {
  width: 100px;
  flex-shrink: 0;
}

.phone-number {
  flex-grow: 1;
}

/* Utility Classes */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }
.text-muted { color: var(--text-secondary); }
.text-success { color: var(--success-color); }
.text-warning { color: var(--warning-color); }
.text-danger { color: var(--error-color); }
.text-info { color: var(--info-color); }

.mb-1 { margin-bottom: 0.5rem; }
.mb-2 { margin-bottom: 1rem; }
.mb-3 { margin-bottom: 1.5rem; }
.mb-4 { margin-bottom: 2rem; }

.mt-1 { margin-top: 0.5rem; }
.mt-2 { margin-top: 1rem; }
.mt-3 { margin-top: 1.5rem; }
.mt-4 { margin-top: 2rem; }

.d-none { display: none; }
.d-block { display: block; }
.d-flex { display: flex; }
.d-grid { display: grid; }

.w-100 { width: 100%; }
.h-100 { height: 100%; }

.flex-1 { flex: 1; }
.flex-center { display: flex; justify-content: center; align-items: center; }
.flex-between { display: flex; justify-content: space-between; align-items: center; }
.flex-column { flex-direction: column; }

.rounded { border-radius: 8px; }
.rounded-lg { border-radius: 12px; }
.rounded-xl { border-radius: 16px; }

.shadow { box-shadow: 0 2px 8px var(--shadow); }
.shadow-lg { box-shadow: 0 4px 20px var(--shadow); }

.border { border: 1px solid var(--border-color); }
.border-accent { border: 1px solid var(--accent-color); }

.bg-primary { background: var(--primary-bg); }
.bg-secondary { background: var(--secondary-bg); }
.bg-accent { background: var(--accent-color); }

.cursor-pointer { cursor: pointer; }
.cursor-not-allowed { cursor: not-allowed; }

.overflow-hidden { overflow: hidden; }
.overflow-scroll { overflow-y: auto; }

.position-relative { position: relative; }
.position-absolute { position: absolute; }
.position-fixed { position: fixed; }

.z-high { z-index: 1000; }
.z-higher { z-index: 2000; }
.z-highest { z-index: 9999; }

.opacity-50 { opacity: 0.5; }
.opacity-75 { opacity: 0.75; }

.transform-scale:hover { transform: scale(1.05); }
.transform-translate:hover { transform: translateY(-2px); }

.transition { transition: all var(--transition-speed); }
.transition-fast { transition: all 0.15s; }
.transition-slow { transition: all 0.6s; }

